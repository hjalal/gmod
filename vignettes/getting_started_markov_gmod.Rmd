---
title: "Getting started with building Markov models using gmod"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with building Markov models using gmod}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
The purpose of this vignette is to provide a step by step guide to illustrate the main features of gmod for markov modeling:

This demo only shows the individual features of gmod. 

To learn more about the capabilities of gmod, please refer to the other tutorial vignettes. 

* works with both decision trees and Markov model so far, but the concepts can be extended to microsimulations and discrete event simulation.. etc.
* highly optimized language that simplifies the way we model to make it closer to the way we describe the model in a human language
* prob and payoff|state, decision, event value, cycle in state, cycle. 
* gmod generates an optimized model function that can be run with various input parameter values. 


* think about the structure of gom by adopting a unified sequence of events
* structure of gmod of decision -> makrov states -> event1 -> event2 -> ... -> last events
* definitions: 
  * state
  * event
  * final_outcomes
  * intermediate outcomes
  * payoffs
  * cycle
  * cycle_in_state
  * decision
  * 
* distinguishing between states and events
* examining the outcomeing equations and formulae
* adding discounting factors
* adding events
* accessing prior (upstream event values)
* adding states

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(gmod)
```

Let's start by building a simple Markov model with a single decisions (StandardOfCare) and with 2 states alive and dead with the probability of dying at 0.1 per year. We will run the model for 10 cycles. 

The gmod syntax will look like this
```{r}
mygmod <- gmod(model_type = "Markov", n_cycles = 10) + 
  decisions("StandardOfCare") + 
  states("Alive", "Dead") + 
  initial_probs(states = "Alive", probs = 1) +  
  event_mapping(event = "die",  
                values = c(T, F), 
                outcomes = c("Dead", curr_state()), 
                probs = c(pDie(state), Inf)) 
```
The sytax above does the following:

* adds creates a gmod Markov object with 10 cycles
* describes a single decision: StandardOfCare
* defines two Markov health states: Alive and Dead
* defines the initial probability that everyone starts healthy 
* defines an event_mapping "die" which can be either TRUE or FALSE, if TRUE, the cohort transitions to Dead with pDie(state), if FALSE the cohort transitions to Alive with probability Inf which is a place holder and computes the complentary probability of 1-pDie(state). curr_state() is a build in function that tells gmod if the event death didn't occur, to keep the cohort in their current state.  

Now, pDie is a function of the state. state is one of the build-in variables that retrieves the state the cohort is in. For example, let's define pDie to return 0.1 if the state is Alive and return 0 otherwise:

```{r}
pDie <- function(state){
  if(state=="Alive") 0.1 else 0
}
```

This is a user-defined function and behaves the same as any other function defined in R. We can simply test what it does under different values of state.
```{r}
pDie(state="Alive")
pDie(state="Dead")
```


Now, we can build our model components from the gmod object above
```{r}
model_struc <- gmod_build(mygmod)
model_struc
```
Then, we can pass this structure to generate the Makrov model function
```{r}
gmod_gen_model_function(model_struc)
```
The function is loaded to the global environment and you can view it by clicking on my_markov_model. We can also print the content of the function by specifying 
```{r}
gmod_gen_model_function(model_struc, print_model_function = T)
```

Finally we can evaluate the Markov model:
```{r}
model_results <- my_markov_model(model_struc, return_transition_prob = T, return_trace = T)
```
We haven't defined any payoffs, so now we are only returning the Markov transition probability matrix with the originating states as rows and the destination states as columns.  The probability of staying alive in each year is 0.9, and probability of dying is 0.1. Once dead will stay dead with a probability of 1. 

we can simply add additional useful information, such as payoffs to the gmod object, for example:
```{r}
mygmod <- gmod(model_type = "Markov", n_cycles = 10) + 
  decisions("StandardOfCare") + 
  states("Alive", "Dead") + 
  initial_probs(states = "Alive", probs = 1) +  
  event_mapping(event = "die",  
                values = c(T, F), 
                outcomes = c("Dead", curr_state()), 
                probs = c(pDie(state), Inf)) + 
  payoffs(utility = utility(state))
```

This will tell gmod to add a payoff layer with a single payoff (utility). This payoff is defined as a function of the state, such that if the state is alive,  the utility will be 0.9, but if dead the utility will be 0. 

```{r}
utility <- function(state){
  if(state=="Alive") 0.9 else 0
}
utility("Alive")
```

Now we can rebuild our model function and rerun it with payoffs:

```{r}
model_struc <- gmod_build(mygmod)
gmod::gmod_gen_model_function(model_struc)
model_results <- my_markov_model(model_struc, return_transition_prob = T, return_trace = T)

```


## with simplification / removing probs that equal and simplifying those that are 1.
```{r}
model_struc <- gmod_build(mygmod, params = list(), simplify = TRUE)
model_struc
```

```{r}
gmod_gen_model_function(model_struc)
```

```{r}
my_markov_model(model_struc = model_struc, return_transition_prob = T, return_trace = T)
```

