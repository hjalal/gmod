[{"path":"/articles/D0_getting_started_decision_models.html","id":"overview-of-gmod","dir":"Articles","previous_headings":"","what":"Overview of gmod:","title":"D0 getting started with decision models using gmod","text":"gmod build grammar modeling principle describes model using simple syntax. gmod inspired grammer graphics (ggplot) package. Similar ggplot builds graph combining layers, gmod writes model code !","code":""},{"path":"/articles/D0_getting_started_decision_models.html","id":"gmod-functions","dir":"Articles","previous_headings":"Overview of gmod:","what":"gmod functions:","title":"D0 getting started with decision models using gmod","text":"gmod two main functions. first function gmod() takes type model (now: decision Markov), number cycles n_cycles (Markov), creates basic gmod object can supplemented one layers containing components deicsion. gmod layers decision tree consist following: decisions: decisions strategies want compare event_mapping: can one . describe events control transition among various outcomes conditional decisions previous events. payoffs: payoffs, costs, effectiveness, utility, … etc. Similar event probabilities, can also depend decisions prior events. second function gmod_gen_model_function() returns two things: creates model code new function named my_decision_model default. returns model structure, list containing parsed objects gmod objects, equations involved final outcome probabilities payoffs. structure needed running model function. my_decision_model() represents entire model structure, can called directly. function takes parameter list param model parameter values, returns results decision model, discounted lifetime costs quality adjusted life-years (QALYs). can also return intermediate outcomes, event probabilities payoffs. Please see function definition documentations. start building minimal decision model illustrate basic structure. , introduce add features. feature, show add feature reduce complexity. full models contain many features model, please refer HSE Doubilet et al vignettes.","code":""},{"path":"/articles/D0_getting_started_decision_models.html","id":"a-minimal-example","dir":"Articles","previous_headings":"","what":"A minimal example","title":"D0 getting started with decision models using gmod","text":"adapt sick-sicker model (ref) often use DARTH materials teachings. First, install gmod using devtools. Also, make sure enable use_vignettes vignettes render correctly. , load gmod library magrittr library needed pipe %>% operator.","code":"#library(devtools) #install_github(\"hjalal/gmod\", use_vignettes = TRUE, force = TRUE) rm(list = ls()) library(gmod) #> To get started with GMOD, please check the vignettes by typing browseVignettes(package = \"gmod\"). library(magrittr)"},{"path":"/articles/D0_getting_started_decision_models.html","id":"defining-a-basic-decision-tree-using-gmod","dir":"Articles","previous_headings":"A minimal example","what":"defining a basic Decision tree using gmod()","title":"D0 getting started with decision models using gmod","text":"start simple decision tree analyze outcome person recently broke leg rock-climbing accident. wound infected two options treatment either amputate lowers quality life less probability dying antibiotics saves leg higher probability death. can write decision problem gmod() : explanation layer : gmod(model_type = \"Decision\"): creates basic gmod object type Decision. decisions(\"Amputate\", \"Antibiotics\"): define two strategies involved. states(\"H\", \"S\", \"D\"): defines Markov states: H healthy, S sick D dead. initial_probs(states = \"H\", probs = 1): defines everyone starts healthy states. See function documentation variations. event = \"die\": defines event name. event must unique name can referenced evnets. values = c(T, F): defines values event: die binary event can either TRUE FALSE. multiple values also possible. probs = c(pDie(decision), Inf)): probabilities event values. flexible feature gmod allows probabilities conditional model components. decision trees, probabilities can functions decisions prior event values explain . define pDie(decision) depends decision single event (die). next section, define pDie. Inf used tell gmod compute complementary probability (.e., 1-pDie(decision)) reduce amount typing needed. outcomes = c(\"Dead\", \"Alive\"): defines outcomes one event values. die==TRUE end outcome Dead, die==FALSE ends Alive outcome. payoffs(utility = compute_utility(decision, state)): defines payoffs. utility payoff dependent decision. one payoff can described . , similar probs argument can function model components, decision prior event values.","code":"mygmod <- gmod() +    decisions(\"Amputate\", \"Antibiotics\") +    event(name = \"die\",               scenarios = c(T, F),              probs = c(pDie(decision), Inf),              outcomes = c(\"Dead\", \"Alive\")) +    payoffs(utility = compute_utility(decision, die))"},{"path":"/articles/D0_getting_started_decision_models.html","id":"user-defined-functions-for-probabilities-and-payoffs","dir":"Articles","previous_headings":"A minimal example","what":"User-defined functions for probabilities and payoffs","title":"D0 getting started with decision models using gmod","text":"section, define two functions: pDie compute_utility use event_mapping payoffs() layers : pDie simple function single ...else statement. Similarly compute_utility also simple function decision. show make function prior events. functions get complex, recommended test make sure return outcomes possible combinations decisions event values. example, simple code tests functions possible combinations decisions. looks like functions returning correct values decision.","code":"# probability of death is 0.99 if the leg amputated and 0.8 if antibiotics given instead. pDie <- function(decision){   if (decision == \"Amputate\") 0.01 else 0.2 }  #The utility is assumed to be 0.7 if the leg is amputated and 0.9 if antibiotics are given.  compute_utility <- function(decision, die){   if(die==TRUE) 0 else   if(decision==\"Amputate\") 0.7 else 0.9 } for (decision in c(\"Amputate\", \"Antibiotics\")){   for (die in c(TRUE, FALSE)){     cat(\"decision:\", decision, \" die :\", die, \" pDie:\", pDie(decision), \" utility:\", compute_utility(decision, die), \"\\n\")   } } #> decision: Amputate  die : TRUE  pDie: 0.01  utility: 0  #> decision: Amputate  die : FALSE  pDie: 0.01  utility: 0.7  #> decision: Antibiotics  die : TRUE  pDie: 0.2  utility: 0  #> decision: Antibiotics  die : FALSE  pDie: 0.2  utility: 0.9"},{"path":"/articles/D0_getting_started_decision_models.html","id":"running-the-model","dir":"Articles","previous_headings":"A minimal example","what":"Running the model","title":"D0 getting started with decision models using gmod","text":"Now ingredients run model. First, need generate model function code create model_struc contains model equations formulae can examined, stated generated note, function also produces function representation decision model. default name function my_decision_model. Let’s examine content two object. First, let’s check model structure examining content structure can helpful debug model examining individual layers formulae. example $final_outcome_formulae returns probability cost formulae path decision plain text. can evaluated calling directly needed. example, want know probability staying alive given Amputate, can simply enter value probs corresponding decision=Amputate final_outcome=Alive Next, can also examine contents my_markov_model function generates text. generated code relatively simple given example. involved examples, please check HSE Doubilet vignettes. Now, let’s run model function generate summary results expected utility decision","code":"model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_decision(mygmod): Model function my_decision_model is generated. It can be run by calling it directly: #> my_decision_model(params) model_struc # returns the model structure including the formulae before evaluation #> $decisions #> [1] \"Amputate\"    \"Antibiotics\" #>  #> $n_decisions #> [1] 2 #>  #> $n_events #> [1] 1 #>  #> $final_outcomes #> [1] \"Dead\"  \"Alive\" #>  #> $n_final_outcomes #> [1] 2 #>  #> $events #> [1] \"die\" #>  #> $payoffs #> $payoffs$utility #> compute_utility(decision, die) #>  #>  #> $payoff_names #> [1] \"utility\" #>  #> $n_payoffs #> [1] 1 #>  #> $final_outcome_formulae #> # A tibble: 4 × 6 #> # Groups:   decision, final_outcome [4] #>   decision    final_outcome path_id probs                     die   utility      #>   <chr>       <chr>           <dbl> <chr>                     <chr> <chr>        #> 1 Amputate    Alive               2 (1-(pDie('Amputate')))    FALSE compute_uti… #> 2 Amputate    Dead                1 (pDie('Amputate'))        TRUE  compute_uti… #> 3 Antibiotics Alive               2 (1-(pDie('Antibiotics'))) FALSE compute_uti… #> 4 Antibiotics Dead                1 (pDie('Antibiotics'))     TRUE  compute_uti… #>  #> $summary_formulae #> # A tibble: 2 × 2 #>   decision    utility                                                            #>   <chr>       <chr>                                                              #> 1 Amputate    (1-(pDie('Amputate')))*compute_utility('Amputate', die=FALSE)+(pD… #> 2 Antibiotics (1-(pDie('Antibiotics')))*compute_utility('Antibiotics', die=FALS… #>  #> attr(,\"class\") #> [1] \"gmod_decision\" (1-(pDie('Amputate'))) #> [1] 0.99 my_decision_model #without parenthesis returns the function text #> function (params = NULL)  #> { #>     if (!is.null(params))  #>         list2env(params, envir = .GlobalEnv) #>     summary_results <- matrix(0, nrow = 2, ncol = 1, dimnames = list(c(\"Amputate\",  #>         \"Antibiotics\"), c(\"utility\"))) #>     summary_results[\"Amputate\", \"utility\"] <- (1 - (pDie(\"Amputate\"))) *  #>         compute_utility(\"Amputate\", die = FALSE) + (pDie(\"Amputate\")) *  #>         compute_utility(\"Amputate\", die = TRUE) #>     summary_results[\"Antibiotics\", \"utility\"] <- (1 - (pDie(\"Antibiotics\"))) *  #>         compute_utility(\"Antibiotics\", die = FALSE) + (pDie(\"Antibiotics\")) *  #>         compute_utility(\"Antibiotics\", die = TRUE) #>     return(summary_results) #> } #> <environment: 0x119de5ea0> my_decision_model() #>             utility #> Amputate      0.693 #> Antibiotics   0.720"},{"path":"/articles/D0_getting_started_decision_models.html","id":"adding-multiple-events","dir":"Articles","previous_headings":"A minimal example","what":"adding multiple events","title":"D0 getting started with decision models using gmod","text":"","code":"mygmod <- gmod() +    decisions(\"Amputate\", \"Antibiotics\") +    event(name = \"get_sick\",               scenarios = c(T, F),              probs = c(pGetSick(decision), Inf),              outcomes = c(\"die\", \"die\")) +    event(name = \"die\",               scenarios = c(T, F),              probs = c(pDie(get_sick), Inf),              outcomes = c(\"Dead\", \"Alive\")) +    payoffs(utility = compute_utility(decision, get_sick, die))  # define pGetSick prob of getting sick is low with amputate = 0.1 but antibiotics is higher 0.3 pGetSick <- function(decision){   if(decision==\"Antibiotics\") 0.3 else 0.1 }  # update probability of dying so it is a function of the prior event getting sick pDie <- function(get_sick){   if (get_sick == TRUE) 0.2 else 0.01 }  #similarly we can make the utility a function of multiple events compute_utility <- function(decision, get_sick, die){   u1 <- if(die==TRUE) 0 else           if(decision==\"Amputate\") 0.7 else 0.9   if(get_sick==TRUE)  u1*0.7 else u1 }  model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_decision(mygmod): Model function my_decision_model is generated. It can be run by calling it directly: #> my_decision_model(params) my_decision_model() #>             utility #> Amputate     0.6629 #> Antibiotics  0.7749"},{"path":"/articles/D0_getting_started_decision_models.html","id":"passing-a-parameter-list-to-the-model","dir":"Articles","previous_headings":"A minimal example","what":"passing a parameter list to the model","title":"D0 getting started with decision models using gmod","text":"far, haven’t passed parameter lists model. model retrieving values needs global environment vignette’s environment. show pass parameters list: can particularly helpful deterministic probabilistic sensitivity analyses can update parameters list pass model function. vignettes defined decision model using gmod. illustrated add decisions events link event together. illustrated make probability one event rely previous events values. showed reveal model structure also model function. addition, illustrated add payoffs make functions decisions previous event values.","code":"params <- list(pDieAmputate = 0.01,                pDieAntibiotics = 0.2,                uAmputate = 0.7,                uAntibiotics = 0.9,                uDead = 0) mygmod <- gmod() +    decisions(\"Amputate\", \"Antibiotics\") +    event(name = \"die\",               scenarios = c(T, F),              probs = c(pDie(decision), Inf),              outcomes = c(\"Dead\", \"Alive\")) +    payoffs(utility = compute_utility(decision, die))  pDie <- function(decision){   if (decision == \"Amputate\") pDieAmputate else pDieAntibiotics }  #The utility is assumed to be 0.7 if the leg is amputated and 0.9 if antibiotics are given.  compute_utility <- function(decision, die){   if(die==TRUE) uDead else   if(decision==\"Amputate\") uAmputate else uAntibiotics }  model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_decision(mygmod): Model function my_decision_model is generated. It can be run by calling it directly: #> my_decision_model(params) my_decision_model(params = params) #>             utility #> Amputate      0.693 #> Antibiotics   0.720"},{"path":"/articles/D1_decision_tree_DARTH_HVE_example.html","id":"gmod","dir":"Articles","previous_headings":"","what":"GMOD","title":"D1 Decision Tree Herpes Virus Encephalopathy","text":"gmod model definition p_comp() takes two arguments, one special keyword decision, custom one. good example custom arguments values can passed define functions event_mapping payoffs. Thus, return values can function arguments can reduce amount typing required one choses define multiple functions. Define model parameters. define custom user functions testing functions outside model","code":"rm(list = ls()) library(gmod) #> To get started with GMOD, please check the vignettes by typing browseVignettes(package = \"gmod\"). mygmod <- gmod() +    decisions(\"DoNotTreat\", \"Treat\", \"Biopsy\") +    #final_outcomes(\"Death\", \"HVE_comp\", \"no_HVE_comp\", \"OVE_comp\", \"no_OVE_comp\") +   #events(\"DIE\", \"HVE\",\"get_comp\") +    event(name = \"DIE\",               scenarios = c(T, F),              probs = c(pDie(decision), Inf),              outcomes = c(\"Death\", \"HVE_event\")) +    event(name = \"HVE_event\",               scenarios = c(T, F),              probs = c(p_HVE, Inf),              outcomes = c(\"get_HVE_comp\", \"get_OVE_comp\")) +   event(name = \"get_HVE_comp\",              scenarios = c(T, F),             probs = c(p_comp(decision, HVE = TRUE), Inf),             outcomes = c(\"HVE_comp\", \"no_HVE_comp\"))  +   event(name = \"get_OVE_comp\",              scenarios = c(T, F),             probs = c(p_comp(decision, HVE = FALSE), Inf),             outcomes = c(\"OVE_comp\", \"no_OVE_comp\")) +    #payoffs(cost = cost(decision, final_outcome, prop_with_event(\"HVE\"=TRUE, decision)),    payoffs(cost = cost(decision, final_outcome),             effectiveness = effectiveness(decision, final_outcome)) v_names_str    <- c(\"No Tx\", \"Tx All\", \"Biopsy\")  # names of strategies n_str          <- length(v_names_str)             # number of strategies wtp            <- 100000                          # willingness to pay threshold  params <- list(         wtp            = 100000 ,                         # willingness to pay threshold          # Probabilities,         p_HVE          = 0.52   ,# prevalence of HVE         p_HVE_comp     = 0.71   ,# complications with untreated HVE         p_OVE_comp     = 0.01   ,# complications with untreated OVE         p_HVE_comp_tx  = 0.36   ,# complications with treated HVE         p_OVE_comp_tx  = 0.20   ,# complications with treated OVE         p_biopsy_death = 0.005  ,# probability of death due to biopsy          # Costs,         c_VE           = 1200   ,# cost of viral encephalitis care without complications         c_VE_comp      = 9000   ,# cost of viral encephalitis care with complications         c_tx           = 9500   ,# cost of treatment         c_biopsy       = 25000  ,# cost of brain biopsy          # QALYs,         q_VE           = 20     ,# remaining QALYs for those without VE-related complications         q_VE_comp      = 19     ,# remaining QALYs for those with VE-related complications         q_loss_biopsy  = 0.01   ,# one-time QALY loss due to brain biopsy         q_death_biopsy = 0      # remaining QALYs for those who died during biopsy ) pDie <- function(decision){   if (decision == \"Biopsy\") p_biopsy_death else 0 }  p_comp <- function(decision, HVE){   if (decision == \"DoNotTreat\" & HVE ) return(p_HVE_comp)   if (decision == \"DoNotTreat\" & !HVE )return(p_OVE_comp)   if (decision == \"Treat\" & HVE ) return(p_HVE_comp_tx)   if (decision == \"Treat\" & !HVE ) return(p_OVE_comp_tx)   if (decision == \"Biopsy\" & HVE) return(p_HVE_comp_tx)   if (decision == \"Biopsy\" & !HVE) return(p_OVE_comp) }  c_HVE <- function(decision){   if (decision == \"biopsy\") c_tx else 0 }  cost <- function(decision, final_outcome){    c_biopsy*(decision==\"Biopsy\") +      c_tx*(decision==\"Treat\" | (decision==\"Biopsy\" & final_outcome %in% c(\"HVE_comp\", \"no_HVE_comp\"))) +      c_VE_comp*(final_outcome %in% c(\"HVE_comp\", \"OVE_comp\")) +      c_VE*(final_outcome %in% c(\"no_HVE_comp\", \"no_OVE_comp\"))  }  effectiveness <- function(decision, final_outcome){   -q_loss_biopsy*(decision==\"Biopsy\") +      q_VE_comp*(final_outcome %in% c(\"HVE_comp\", \"OVE_comp\")) +      q_VE*(final_outcome %in% c(\"no_HVE_comp\", \"no_OVE_comp\")) } #p_comp(decision = \"Biopsy\", HVE = FALSE) # #cost(\"Biopsy\", \"HVE_comp\") #effectiveness(\"Biopsy\", \"Death\") model_struc <- gmod_build(mygmod) model_struc #> $decisions #> [1] \"DoNotTreat\" \"Treat\"      \"Biopsy\"     #>  #> $n_decisions #> [1] 3 #>  #> $n_events #> [1] 4 #>  #> $final_outcomes #> [1] \"Death\"       \"HVE_comp\"    \"no_HVE_comp\" \"OVE_comp\"    \"no_OVE_comp\" #>  #> $n_final_outcomes #> [1] 5 #>  #> $events #> [1] \"DIE\"          \"HVE_event\"    \"get_HVE_comp\" \"get_OVE_comp\" #>  #> $payoffs #> $payoffs$cost #> cost(decision, final_outcome) #>  #> $payoffs$effectiveness #> effectiveness(decision, final_outcome) #>  #>  #> $payoff_names #> [1] \"cost\"          \"effectiveness\" #>  #> $n_payoffs #> [1] 2 #>  #> $final_outcome_formulae #> # A tibble: 15 × 10 #> # Groups:   decision, final_outcome [15] #>    decision   final_outcome path_id probs           DIE   HVE_event get_HVE_comp #>    <chr>      <chr>           <dbl> <chr>           <chr> <chr>     <chr>        #>  1 Biopsy     Death               1 (pDie('Biopsy'… TRUE  FALSE     FALSE        #>  2 Biopsy     HVE_comp            2 (1-(pDie('Biop… FALSE TRUE      TRUE         #>  3 Biopsy     OVE_comp            4 (1-(pDie('Biop… FALSE FALSE     FALSE        #>  4 Biopsy     no_HVE_comp         3 (1-(pDie('Biop… FALSE TRUE      FALSE        #>  5 Biopsy     no_OVE_comp         5 (1-(pDie('Biop… FALSE FALSE     FALSE        #>  6 DoNotTreat Death               1 (pDie('DoNotTr… TRUE  FALSE     FALSE        #>  7 DoNotTreat HVE_comp            2 (1-(pDie('DoNo… FALSE TRUE      TRUE         #>  8 DoNotTreat OVE_comp            4 (1-(pDie('DoNo… FALSE FALSE     FALSE        #>  9 DoNotTreat no_HVE_comp         3 (1-(pDie('DoNo… FALSE TRUE      FALSE        #> 10 DoNotTreat no_OVE_comp         5 (1-(pDie('DoNo… FALSE FALSE     FALSE        #> 11 Treat      Death               1 (pDie('Treat')) TRUE  FALSE     FALSE        #> 12 Treat      HVE_comp            2 (1-(pDie('Trea… FALSE TRUE      TRUE         #> 13 Treat      OVE_comp            4 (1-(pDie('Trea… FALSE FALSE     FALSE        #> 14 Treat      no_HVE_comp         3 (1-(pDie('Trea… FALSE TRUE      FALSE        #> 15 Treat      no_OVE_comp         5 (1-(pDie('Trea… FALSE FALSE     FALSE        #> # ℹ 3 more variables: get_OVE_comp <chr>, cost <chr>, effectiveness <chr> #>  #> $summary_formulae #> # A tibble: 3 × 3 #>   decision   cost                                                  effectiveness #>   <chr>      <chr>                                                 <chr>         #> 1 Biopsy     (pDie('Biopsy'))*cost('Biopsy', 'Death')+(1-(pDie('B… (pDie('Biops… #> 2 DoNotTreat (pDie('DoNotTreat'))*cost('DoNotTreat', 'Death')+(1-… (pDie('DoNot… #> 3 Treat      (pDie('Treat'))*cost('Treat', 'Death')+(1-(pDie('Tre… (pDie('Treat… #>  #> attr(,\"class\") #> [1] \"gmod_decision\" model_res <- gmod_gen_model_function(model_struc) #> Warning in gmod_gen_model_function.gmod_decision(model_struc): Model function my_decision_model is generated. It can be run by calling it directly: #> my_decision_model(params) model_res #> $decisions #> [1] \"DoNotTreat\" \"Treat\"      \"Biopsy\"     #>  #> $n_decisions #> [1] 3 #>  #> $n_events #> [1] 4 #>  #> $final_outcomes #> [1] \"Death\"       \"HVE_comp\"    \"no_HVE_comp\" \"OVE_comp\"    \"no_OVE_comp\" #>  #> $n_final_outcomes #> [1] 5 #>  #> $events #> [1] \"DIE\"          \"HVE_event\"    \"get_HVE_comp\" \"get_OVE_comp\" #>  #> $payoffs #> $payoffs$cost #> cost(decision, final_outcome) #>  #> $payoffs$effectiveness #> effectiveness(decision, final_outcome) #>  #>  #> $payoff_names #> [1] \"cost\"          \"effectiveness\" #>  #> $n_payoffs #> [1] 2 #>  #> $final_outcome_formulae #> # A tibble: 15 × 10 #> # Groups:   decision, final_outcome [15] #>    decision   final_outcome path_id probs           DIE   HVE_event get_HVE_comp #>    <chr>      <chr>           <dbl> <chr>           <chr> <chr>     <chr>        #>  1 Biopsy     Death               1 (pDie('Biopsy'… TRUE  FALSE     FALSE        #>  2 Biopsy     HVE_comp            2 (1-(pDie('Biop… FALSE TRUE      TRUE         #>  3 Biopsy     OVE_comp            4 (1-(pDie('Biop… FALSE FALSE     FALSE        #>  4 Biopsy     no_HVE_comp         3 (1-(pDie('Biop… FALSE TRUE      FALSE        #>  5 Biopsy     no_OVE_comp         5 (1-(pDie('Biop… FALSE FALSE     FALSE        #>  6 DoNotTreat Death               1 (pDie('DoNotTr… TRUE  FALSE     FALSE        #>  7 DoNotTreat HVE_comp            2 (1-(pDie('DoNo… FALSE TRUE      TRUE         #>  8 DoNotTreat OVE_comp            4 (1-(pDie('DoNo… FALSE FALSE     FALSE        #>  9 DoNotTreat no_HVE_comp         3 (1-(pDie('DoNo… FALSE TRUE      FALSE        #> 10 DoNotTreat no_OVE_comp         5 (1-(pDie('DoNo… FALSE FALSE     FALSE        #> 11 Treat      Death               1 (pDie('Treat')) TRUE  FALSE     FALSE        #> 12 Treat      HVE_comp            2 (1-(pDie('Trea… FALSE TRUE      TRUE         #> 13 Treat      OVE_comp            4 (1-(pDie('Trea… FALSE FALSE     FALSE        #> 14 Treat      no_HVE_comp         3 (1-(pDie('Trea… FALSE TRUE      FALSE        #> 15 Treat      no_OVE_comp         5 (1-(pDie('Trea… FALSE FALSE     FALSE        #> # ℹ 3 more variables: get_OVE_comp <chr>, cost <chr>, effectiveness <chr> #>  #> $summary_formulae #> # A tibble: 3 × 3 #>   decision   cost                                                  effectiveness #>   <chr>      <chr>                                                 <chr>         #> 1 Biopsy     (pDie('Biopsy'))*cost('Biopsy', 'Death')+(1-(pDie('B… (pDie('Biops… #> 2 DoNotTreat (pDie('DoNotTreat'))*cost('DoNotTreat', 'Death')+(1-… (pDie('DoNot… #> 3 Treat      (pDie('Treat'))*cost('Treat', 'Death')+(1-(pDie('Tre… (pDie('Treat… #>  #> attr(,\"class\") #> [1] \"gmod_decision\" my_decision_model(params) #>                cost effectiveness #> Biopsy     32599.41      19.69896 #> DoNotTreat  4117.20      19.62600 #> Treat      12908.96      19.71680"},{"path":"/articles/D1_decision_tree_DARTH_HVE_example.html","id":"direct-coding-in-r","dir":"Articles","previous_headings":"","what":"Direct coding in R","title":"D1 Decision Tree Herpes Virus Encephalopathy","text":"code looks like one wants code transitions R directly without using gmod","code":"# Create vector of weights for each strategy     v_w_no_tx  <- c(    p_HVE  *      p_HVE_comp     ,  # HVE, complications                     p_HVE  * (1 - p_HVE_comp)    ,  # HVE, no complications                (1 - p_HVE) *      p_OVE_comp     ,  # OVE, complications                (1 - p_HVE) * (1 - p_OVE_comp))      # OVE, no complications    v_w_tx     <- c(    p_HVE  *      p_HVE_comp_tx  ,  # HVE w/tx, complications                     p_HVE  * (1 - p_HVE_comp_tx) ,  # HVE w/tx, no complications                (1 - p_HVE) *      p_OVE_comp_tx  ,  # OVE w/tx, complications                (1 - p_HVE) * (1 - p_OVE_comp_tx))   # OVE w/tx, no complications    v_w_biopsy <- c(p_biopsy_death                   ,  # biopsy death                # no biopsy death.,   HVE w/tx,        complications                (1-p_biopsy_death)   *    p_HVE  *    p_HVE_comp_tx  ,                  # no biopsy death.,   HVE w/tx,     no complications                (1-p_biopsy_death)   *    p_HVE  * (1-p_HVE_comp_tx) ,                  # no biopsy death.,        OVE,        complications                (1-p_biopsy_death)   * (1-p_HVE) *      p_OVE_comp   ,                  # no biopsy death.,        OVE,     no complications                (1-p_biopsy_death)   * (1-p_HVE) * (1 - p_OVE_comp))          # Create vector of final_outcomes (QALYs) for each strategy     v_qaly_no_tx  <- c(q_VE_comp ,          # HVE, complications                    q_VE      ,          # HVE, no complications                    q_VE_comp ,          # OVE, complications                    q_VE)                # OVE, no complications    v_qaly_tx     <- c(q_VE_comp ,          # HVE, complications                    q_VE      ,          # HVE, no complications                    q_VE_comp ,          # OVE, complications                    q_VE)                # OVE, no complications       v_qaly_biopsy <- -q_loss_biopsy     +   # loss due to biopsy                   c(q_death_biopsy  ,   # biopsy complications                     q_VE_comp       ,   # no biopsy comp., HVE w/tx, complications                      q_VE            ,   # no biopsy comp., HVE w/tx, no complications                     q_VE_comp       ,   # no biopsy comp., OVE, complications                     q_VE)               # no biopsy comp., OVE, no complications    # Create vector of costs for each strategy     v_cost_no_tx  <- c(c_VE_comp ,          # HVE, complications                    c_VE      ,          # HVE, no complications                    c_VE_comp ,          # OVE, complications                    c_VE)                # OVE, no complications    v_cost_tx     <- c_tx +                 # cost of treatment                  c(c_VE_comp ,          # HVE, complications                    c_VE      ,          # HVE, no complications                    c_VE_comp ,          # OVE, complications                    c_VE)                # OVE, no complications    v_cost_biopsy <- c_biopsy           +   # cost of biopsy procedure                  c(0                ,   # cost of death (zero)                    c_VE_comp + c_tx ,   # no biopsy comp., HVE w/tx, complications                     c_VE + c_tx      ,   # no biopsy comp., HVE w/tx, no complications                    c_VE_comp        ,   # no biopsy comp., OVE, complications                    c_VE)                # no biopsy comp., OVE, no complications   # Calculate total utilities for each strategy  total_qaly_no_tx  <- v_w_no_tx  %*%  v_qaly_no_tx       total_qaly_tx     <- v_w_tx     %*%  v_qaly_tx total_qaly_biopsy <- v_w_biopsy %*%  v_qaly_biopsy    # Calculate total costs for each strategy  total_cost_no_tx  <- v_w_no_tx  %*%  v_cost_no_tx     total_cost_tx     <- v_w_tx     %*%  v_cost_tx total_cost_biopsy <- v_w_biopsy %*%  v_cost_biopsy    # vector of total QALYs v_total_qaly <- c(total_qaly_no_tx, total_qaly_tx, total_qaly_biopsy)  # vector of total costs v_total_cost <- c(total_cost_no_tx, total_cost_tx, total_cost_biopsy)  # calculate vector of nmb v_nmb        <- v_total_qaly * wtp - v_total_cost                          # Name final_outcomes names(v_total_qaly) <- v_names_str  # names for the elements of the total QALYs vector names(v_total_cost) <- v_names_str  # names for the elements of the total cost vector names(v_nmb)        <- v_names_str  # names for the elements of the nmb vector    df_output <- data.frame(Strategy =  v_names_str,                         Cost     =  v_total_cost,                         Effect   =  v_total_qaly,                         NMB      =  v_nmb)  # model output df_output #>        Strategy     Cost   Effect     NMB #> No Tx     No Tx  4117.20 19.62600 1958483 #> Tx All   Tx All 12908.96 19.71680 1958771 #> Biopsy   Biopsy 32599.41 19.69896 1937297"},{"path":"/articles/D3_dec_tree_Doubilet_1985_example.html","id":"binary-event-final_outcomes-similar-to-doubilet-1985","dir":"Articles","previous_headings":"","what":"Binary event final_outcomes similar to Doubilet 1985","title":"D3 Herpes Simplex Decision Tree Example Doubilet 1985","text":"","code":"mygmod <- gmod() +    decisions(\"BrainBiopsy\", \"NoBiopsy_Treat\", \"NoBiopsy_NoTreat\") +    #final_outcomes(\"DEAD\",\"SEVSEQHSE\",\"MODSEQHSE\",\"MLDSEQHSE\") +    event(name = \"Biopsy\",                   scenarios = c(TRUE, FALSE),                  probs = c(pBiopsy(decision), Inf),                  outcomes = c(\"dieBiop\", \"HSE\"))  +    event(name = \"dieBiop\",                   scenarios = c(TRUE, FALSE),                  probs = c(pDieBiopsy, Inf),                  outcomes = c(\"DEAD\", \"sevBiopSeq\"))  +    event(name = \"sevBiopSeq\",                   scenarios = c(TRUE, FALSE),                  probs = c(pSevBiopsy, Inf),                  outcomes = c(\"HSE\", \"modBiopSeq\"))  +    event(name = \"modBiopSeq\",                   scenarios = c(TRUE, FALSE),                  probs = c(pModBiopsy, Inf),                  outcomes = c(\"HSE\", \"HSE\"))  +    event(name = \"HSE\",                   scenarios = c(TRUE, FALSE),                  probs = c(pHSE, Inf),                  outcomes = c(\"BiopAvail\", \"BiopAvail\"))  +   event(name = \"BiopAvail\",                   scenarios = c(TRUE, FALSE),                  probs = c(pBiopsy(decision), Inf),                  outcomes = c(\"BiopRes\", \"die\"))  +    event(name = \"BiopRes\",                   #scenarios = c(\"Positive\", \"Negative\"),                  scenarios = c(TRUE, FALSE),                  probs = c(pBiopRes(HSE), Inf),                  outcomes = c(\"die\", \"die\"))  +    event(name = \"die\",                   scenarios = c(T, F),                  probs = c(pEvent(HSE, decision, BiopRes, pDieHSE, pDieNoHSE, fDie, addProbDie), Inf),                  outcomes = c(\"DEAD\", \"sevSeqHSE\")) +   event(name = \"sevSeqHSE\",                   scenarios = c(T, F),                  probs = c(pEvent(HSE, decision, BiopRes, pSevHSE, pSevNoHSE, fSev, addProbSev), Inf),                  outcomes = c(\"SEVSEQHSE\", \"modSeqHSE\")) +   event(name = \"modSeqHSE\",                   scenarios = c(T, F),                  probs = c(pEvent(HSE, decision, BiopRes, pModHSE, pModNoHSE, fMod, addProbMod), Inf),                  outcomes = c(\"MODSEQHSE\", \"MLDSEQHSE\")) +    payoffs(util = util(decision, final_outcome, sevBiopSeq, modBiopSeq)) pEvent <- function(HSE, decision, BiopRes, pEventHSE, pEventNoHSE, fEvent, addProbEvent){   pEventRx <- if (HSE){               (1-fEvent)*pEventHSE                } else {                 pEventNoHSE+addProbEvent-pEventNoHSE*addProbEvent               }   pEventNoRx <- if (HSE) pEventHSE else pEventNoHSE   if (decision==\"NoBiopsy_NoTreat\") pEventNoRx else      if (decision==\"NoBiopsy_Treat\") pEventRx else        if (decision==\"BrainBiopsy\")          if (BiopRes) pEventRx else pEventNoRx } pBiopsy <- function(decision){   (decision==\"BrainBiopsy\") } pBiopRes <- function(HSE){   HSE*sensBiopsy + (!HSE)*(1-specBiopsy) } util <- function(decision, final_outcome, sevBiopSeq, modBiopSeq){   if (decision==\"BrainBiopsy\"){     if (!is.na(sevBiopSeq) & sevBiopSeq){       uMult <- uSev     } else {       if (!is.na(modBiopSeq) & modBiopSeq){         uMult <- uMod       } else {         uMult <- uMld       }     }   } else {     uMult <- 1   }   # uMult <- (decision==\"BrainBiopsy\")*(sevBiopSeq*uSev + modBiopSeq*uMod + (!modBiopSeq)*uMld) +    #   (decision!=\"BrainBiopsy\")   #print(uMult)   switch(final_outcome,          \"DEAD\" = uDie,          \"SEVSEQHSE\" = uSev*uMult,           \"MODSEQHSE\" = uMod*uMult,           \"MLDSEQHSE\" = uMld*uMult) } model_struc <- gmod_build(mygmod) model_struc #> $decisions #> [1] \"BrainBiopsy\"      \"NoBiopsy_Treat\"   \"NoBiopsy_NoTreat\" #>  #> $n_decisions #> [1] 3 #>  #> $n_events #> [1] 10 #>  #> $final_outcomes #> [1] \"DEAD\"      \"SEVSEQHSE\" \"MODSEQHSE\" \"MLDSEQHSE\" #>  #> $n_final_outcomes #> [1] 4 #>  #> $events #>  [1] \"Biopsy\"     \"dieBiop\"    \"sevBiopSeq\" \"modBiopSeq\" \"HSE\"        #>  [6] \"BiopAvail\"  \"BiopRes\"    \"die\"        \"sevSeqHSE\"  \"modSeqHSE\"  #>  #> $payoffs #> $payoffs$util #> util(decision, final_outcome, sevBiopSeq, modBiopSeq) #>  #>  #> $payoff_names #> [1] \"util\" #>  #> $n_payoffs #> [1] 1 #>  #> $final_outcome_formulae #> # A tibble: 291 × 15 #> # Groups:   decision, final_outcome [12] #>    decision    final_outcome path_id probs  Biopsy dieBiop sevBiopSeq modBiopSeq #>    <chr>       <chr>           <dbl> <chr>  <chr>  <chr>   <chr>      <chr>      #>  1 BrainBiopsy DEAD                1 (pBio… TRUE   TRUE    FALSE      FALSE      #>  2 BrainBiopsy DEAD                2 (1-(p… FALSE  FALSE   FALSE      FALSE      #>  3 BrainBiopsy DEAD                3 (pBio… TRUE   FALSE   TRUE       FALSE      #>  4 BrainBiopsy DEAD                4 (pBio… TRUE   FALSE   FALSE      TRUE       #>  5 BrainBiopsy DEAD                5 (pBio… TRUE   FALSE   FALSE      FALSE      #>  6 BrainBiopsy DEAD                6 (1-(p… FALSE  FALSE   FALSE      FALSE      #>  7 BrainBiopsy DEAD                7 (pBio… TRUE   FALSE   TRUE       FALSE      #>  8 BrainBiopsy DEAD                8 (pBio… TRUE   FALSE   FALSE      TRUE       #>  9 BrainBiopsy DEAD                9 (pBio… TRUE   FALSE   FALSE      FALSE      #> 10 BrainBiopsy DEAD               10 (1-(p… FALSE  FALSE   FALSE      FALSE      #> # ℹ 281 more rows #> # ℹ 7 more variables: HSE <chr>, BiopAvail <chr>, BiopRes <chr>, die <chr>, #> #   sevSeqHSE <chr>, modSeqHSE <chr>, util <chr> #>  #> $summary_formulae #> # A tibble: 3 × 2 #>   decision         util                                                          #>   <chr>            <chr>                                                         #> 1 BrainBiopsy      (pBiopsy('BrainBiopsy'))*(pDieBiopsy)*util('BrainBiopsy', 'D… #> 2 NoBiopsy_NoTreat (pBiopsy('NoBiopsy_NoTreat'))*(pDieBiopsy)*util('NoBiopsy_No… #> 3 NoBiopsy_Treat   (pBiopsy('NoBiopsy_Treat'))*(pDieBiopsy)*util('NoBiopsy_Trea… #>  #> attr(,\"class\") #> [1] \"gmod_decision\" gmod_gen_model_function(model_struc, model_function_name = \"doubilet_1985_model\") #> Warning in gmod_gen_model_function.gmod_decision(model_struc, model_function_name = \"doubilet_1985_model\"): Model function doubilet_1985_model is generated. It can be run by calling it directly: #> doubilet_1985_model(params) #> $decisions #> [1] \"BrainBiopsy\"      \"NoBiopsy_Treat\"   \"NoBiopsy_NoTreat\" #>  #> $n_decisions #> [1] 3 #>  #> $n_events #> [1] 10 #>  #> $final_outcomes #> [1] \"DEAD\"      \"SEVSEQHSE\" \"MODSEQHSE\" \"MLDSEQHSE\" #>  #> $n_final_outcomes #> [1] 4 #>  #> $events #>  [1] \"Biopsy\"     \"dieBiop\"    \"sevBiopSeq\" \"modBiopSeq\" \"HSE\"        #>  [6] \"BiopAvail\"  \"BiopRes\"    \"die\"        \"sevSeqHSE\"  \"modSeqHSE\"  #>  #> $payoffs #> $payoffs$util #> util(decision, final_outcome, sevBiopSeq, modBiopSeq) #>  #>  #> $payoff_names #> [1] \"util\" #>  #> $n_payoffs #> [1] 1 #>  #> $final_outcome_formulae #> # A tibble: 291 × 15 #> # Groups:   decision, final_outcome [12] #>    decision    final_outcome path_id probs  Biopsy dieBiop sevBiopSeq modBiopSeq #>    <chr>       <chr>           <dbl> <chr>  <chr>  <chr>   <chr>      <chr>      #>  1 BrainBiopsy DEAD                1 (pBio… TRUE   TRUE    FALSE      FALSE      #>  2 BrainBiopsy DEAD                2 (1-(p… FALSE  FALSE   FALSE      FALSE      #>  3 BrainBiopsy DEAD                3 (pBio… TRUE   FALSE   TRUE       FALSE      #>  4 BrainBiopsy DEAD                4 (pBio… TRUE   FALSE   FALSE      TRUE       #>  5 BrainBiopsy DEAD                5 (pBio… TRUE   FALSE   FALSE      FALSE      #>  6 BrainBiopsy DEAD                6 (1-(p… FALSE  FALSE   FALSE      FALSE      #>  7 BrainBiopsy DEAD                7 (pBio… TRUE   FALSE   TRUE       FALSE      #>  8 BrainBiopsy DEAD                8 (pBio… TRUE   FALSE   FALSE      TRUE       #>  9 BrainBiopsy DEAD                9 (pBio… TRUE   FALSE   FALSE      FALSE      #> 10 BrainBiopsy DEAD               10 (1-(p… FALSE  FALSE   FALSE      FALSE      #> # ℹ 281 more rows #> # ℹ 7 more variables: HSE <chr>, BiopAvail <chr>, BiopRes <chr>, die <chr>, #> #   sevSeqHSE <chr>, modSeqHSE <chr>, util <chr> #>  #> $summary_formulae #> # A tibble: 3 × 2 #>   decision         util                                                          #>   <chr>            <chr>                                                         #> 1 BrainBiopsy      (pBiopsy('BrainBiopsy'))*(pDieBiopsy)*util('BrainBiopsy', 'D… #> 2 NoBiopsy_NoTreat (pBiopsy('NoBiopsy_NoTreat'))*(pDieBiopsy)*util('NoBiopsy_No… #> 3 NoBiopsy_Treat   (pBiopsy('NoBiopsy_Treat'))*(pDieBiopsy)*util('NoBiopsy_Trea… #>  #> attr(,\"class\") #> [1] \"gmod_decision\" doubilet_1985_model(params) #>                       util #> BrainBiopsy      0.5580326 #> NoBiopsy_NoTreat 0.4940027 #> NoBiopsy_Treat   0.5660208"},{"path":"/articles/D3_dec_tree_Doubilet_1985_example.html","id":"with-simplification---where-paths-that-generate-0-prob-are-removed","dir":"Articles","previous_headings":"Binary event final_outcomes similar to Doubilet 1985","what":"with simplification - where paths that generate 0 prob are removed","title":"D3 Herpes Simplex Decision Tree Example Doubilet 1985","text":"","code":"model_struc <- gmod_build(mygmod, params = params, simplify = TRUE) model_struc #> $decisions #> [1] \"BrainBiopsy\"      \"NoBiopsy_Treat\"   \"NoBiopsy_NoTreat\" #>  #> $n_decisions #> [1] 3 #>  #> $n_events #> [1] 10 #>  #> $final_outcomes #> [1] \"DEAD\"      \"SEVSEQHSE\" \"MODSEQHSE\" \"MLDSEQHSE\" #>  #> $n_final_outcomes #> [1] 4 #>  #> $events #>  [1] \"Biopsy\"     \"dieBiop\"    \"sevBiopSeq\" \"modBiopSeq\" \"HSE\"        #>  [6] \"BiopAvail\"  \"BiopRes\"    \"die\"        \"sevSeqHSE\"  \"modSeqHSE\"  #>  #> $payoffs #> $payoffs$util #> util(decision, final_outcome, sevBiopSeq, modBiopSeq) #>  #>  #> $payoff_names #> [1] \"util\" #>  #> $n_payoffs #> [1] 1 #>  #> $final_outcome_formulae #> # A tibble: 291 × 15 #> # Groups:   decision, final_outcome [12] #>    decision    final_outcome path_id probs  Biopsy dieBiop sevBiopSeq modBiopSeq #>    <chr>       <chr>           <dbl> <chr>  <chr>  <chr>   <chr>      <chr>      #>  1 BrainBiopsy DEAD                1 (pBio… TRUE   TRUE    FALSE      FALSE      #>  2 BrainBiopsy DEAD                2 (1-(p… FALSE  FALSE   FALSE      FALSE      #>  3 BrainBiopsy DEAD                3 (pBio… TRUE   FALSE   TRUE       FALSE      #>  4 BrainBiopsy DEAD                4 (pBio… TRUE   FALSE   FALSE      TRUE       #>  5 BrainBiopsy DEAD                5 (pBio… TRUE   FALSE   FALSE      FALSE      #>  6 BrainBiopsy DEAD                6 (1-(p… FALSE  FALSE   FALSE      FALSE      #>  7 BrainBiopsy DEAD                7 (pBio… TRUE   FALSE   TRUE       FALSE      #>  8 BrainBiopsy DEAD                8 (pBio… TRUE   FALSE   FALSE      TRUE       #>  9 BrainBiopsy DEAD                9 (pBio… TRUE   FALSE   FALSE      FALSE      #> 10 BrainBiopsy DEAD               10 (1-(p… FALSE  FALSE   FALSE      FALSE      #> # ℹ 281 more rows #> # ℹ 7 more variables: HSE <chr>, BiopAvail <chr>, BiopRes <chr>, die <chr>, #> #   sevSeqHSE <chr>, modSeqHSE <chr>, util <chr> #>  #> $summary_formulae #> # A tibble: 3 × 2 #>   decision         util                                                          #>   <chr>            <chr>                                                         #> 1 BrainBiopsy      (pBiopsy('BrainBiopsy'))*(pDieBiopsy)*util('BrainBiopsy', 'D… #> 2 NoBiopsy_NoTreat (1-(pBiopsy('NoBiopsy_NoTreat')))*(pHSE)*(1-(pBiopsy('NoBiop… #> 3 NoBiopsy_Treat   (1-(pBiopsy('NoBiopsy_Treat')))*(pHSE)*(1-(pBiopsy('NoBiopsy… #>  #> attr(,\"class\") #> [1] \"gmod_decision\" gmod_gen_model_function(model_struc, model_function_name = \"doubilet_1985_model\") #> Warning in gmod_gen_model_function.gmod_decision(model_struc, model_function_name = \"doubilet_1985_model\"): Model function doubilet_1985_model is generated. It can be run by calling it directly: #> doubilet_1985_model(params) #> $decisions #> [1] \"BrainBiopsy\"      \"NoBiopsy_Treat\"   \"NoBiopsy_NoTreat\" #>  #> $n_decisions #> [1] 3 #>  #> $n_events #> [1] 10 #>  #> $final_outcomes #> [1] \"DEAD\"      \"SEVSEQHSE\" \"MODSEQHSE\" \"MLDSEQHSE\" #>  #> $n_final_outcomes #> [1] 4 #>  #> $events #>  [1] \"Biopsy\"     \"dieBiop\"    \"sevBiopSeq\" \"modBiopSeq\" \"HSE\"        #>  [6] \"BiopAvail\"  \"BiopRes\"    \"die\"        \"sevSeqHSE\"  \"modSeqHSE\"  #>  #> $payoffs #> $payoffs$util #> util(decision, final_outcome, sevBiopSeq, modBiopSeq) #>  #>  #> $payoff_names #> [1] \"util\" #>  #> $n_payoffs #> [1] 1 #>  #> $final_outcome_formulae #> # A tibble: 291 × 15 #> # Groups:   decision, final_outcome [12] #>    decision    final_outcome path_id probs  Biopsy dieBiop sevBiopSeq modBiopSeq #>    <chr>       <chr>           <dbl> <chr>  <chr>  <chr>   <chr>      <chr>      #>  1 BrainBiopsy DEAD                1 (pBio… TRUE   TRUE    FALSE      FALSE      #>  2 BrainBiopsy DEAD                2 (1-(p… FALSE  FALSE   FALSE      FALSE      #>  3 BrainBiopsy DEAD                3 (pBio… TRUE   FALSE   TRUE       FALSE      #>  4 BrainBiopsy DEAD                4 (pBio… TRUE   FALSE   FALSE      TRUE       #>  5 BrainBiopsy DEAD                5 (pBio… TRUE   FALSE   FALSE      FALSE      #>  6 BrainBiopsy DEAD                6 (1-(p… FALSE  FALSE   FALSE      FALSE      #>  7 BrainBiopsy DEAD                7 (pBio… TRUE   FALSE   TRUE       FALSE      #>  8 BrainBiopsy DEAD                8 (pBio… TRUE   FALSE   FALSE      TRUE       #>  9 BrainBiopsy DEAD                9 (pBio… TRUE   FALSE   FALSE      FALSE      #> 10 BrainBiopsy DEAD               10 (1-(p… FALSE  FALSE   FALSE      FALSE      #> # ℹ 281 more rows #> # ℹ 7 more variables: HSE <chr>, BiopAvail <chr>, BiopRes <chr>, die <chr>, #> #   sevSeqHSE <chr>, modSeqHSE <chr>, util <chr> #>  #> $summary_formulae #> # A tibble: 3 × 2 #>   decision         util                                                          #>   <chr>            <chr>                                                         #> 1 BrainBiopsy      (pBiopsy('BrainBiopsy'))*(pDieBiopsy)*util('BrainBiopsy', 'D… #> 2 NoBiopsy_NoTreat (pBiopsy('NoBiopsy_NoTreat'))*(pDieBiopsy)*util('NoBiopsy_No… #> 3 NoBiopsy_Treat   (pBiopsy('NoBiopsy_Treat'))*(pDieBiopsy)*util('NoBiopsy_Trea… #>  #> attr(,\"class\") #> [1] \"gmod_decision\" doubilet_1985_model(params) #>                       util #> BrainBiopsy      0.5580326 #> NoBiopsy_NoTreat 0.4940027 #> NoBiopsy_Treat   0.5660208"},{"path":"/articles/D3_dec_tree_Doubilet_1985_example.html","id":"doubilet-1985-table-2-results","dir":"Articles","previous_headings":"Binary event final_outcomes similar to Doubilet 1985","what":"Doubilet 1985 Table 2 Results","title":"D3 Herpes Simplex Decision Tree Example Doubilet 1985","text":"tree good example events can reduced significantly tree structure can simplified. plot shows full expansion Doubilet model looks like shown using OpenTree R package.","code":""},{"path":[]},{"path":"/articles/D3_dec_tree_Doubilet_1985_example.html","id":"multiple-final_outcomes-per-event","dir":"Articles","previous_headings":"","what":"Multiple final_outcomes per event","title":"D3 Herpes Simplex Decision Tree Example Doubilet 1985","text":"impact reducing binary final_outcomes gmod structure.","code":""},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"overview-of-gmod","dir":"Articles","previous_headings":"","what":"Overview of gmod:","title":"M0 gmod: getting started with building Markov models","text":"gmod built grammar modeling principle aims describe model terms main components. idea reduce complexity decision/Markov model ’s principal components (Twigs). gmod inspired grammer graphics (ggplot) grammar data wranggling (dplyr) package data wrangling. Similar ggplot builds graph combining layers, gmod writes model code !","code":""},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"gmod-functions","dir":"Articles","previous_headings":"Overview of gmod:","what":"gmod functions:","title":"M0 gmod: getting started with building Markov models","text":"gmod two main external functions. first function gmod() instantiates basic gmod object can supplemented one twigs containing components Markov model. gmod syntax Markov model currently consist following twigs: decisions: single twig lists decisions strategies want compare states: single twig describes Markov states, initial probabitlities number tunnel cycles (defaults 1). event: one twig describing, events control transition among states. transitions can conditional decisions, Markov states, previous events, number cycles, number cycles state (.e., tunnels). payoffs: single payoff twig, costs, effectiveness, utility, … etc. Similar events, can also depend decisions, Markov states, events, number cycles, number cycles state (.e., tunnels). second function gmod_gen_model_function() returns mainly creates new function named my_markov_model represents model code standard R can run independently gmod. function also returns useful information, model structure equations involved transition probabilities payoffs …etc. my_markov_model() represents entire model structure, can called directly. function takes parameter list param include model parameter values, returns Markov results, discounted lifetime costs quality adjusted life-years (QALYs). important pass number cycles n_cycles parameter discussed . described , addition main payoffs, function can also return intermediate outputs, transitional probability matrices, cohort’s Markov trace time, others. start building minimal Markov model illustrate basic principles gmod. , introduce add functionality, cycle dependency, tunnels…etc. feature, show add feature reduce complexity. full models contain many features model, please refer introductory advanced Markov tutorials vignettes.","code":""},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"a-minimal-example","dir":"Articles","previous_headings":"","what":"A minimal example","title":"M0 gmod: getting started with building Markov models","text":"adapt sick-sicker model (ref) often use DARTH materials teachings. First, install gmod using devtools. Also, make sure enable use_vignettes vignettes render correctly. , load gmod library magrittr library needed pipe %>% operator.","code":"#library(devtools) #install_github(\"hjalal/gmod\", use_vignettes = TRUE, force = TRUE) rm(list = ls()) library(gmod) #> To get started with GMOD, please check the vignettes by typing browseVignettes(package = \"gmod\"). library(magrittr)"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"defining-a-basic-markov-model-using-gmod-and-decision-twigs","dir":"Articles","previous_headings":"A minimal example","what":"defining a basic Markov model using gmod() and Decision Twigs","title":"M0 gmod: getting started with building Markov models","text":"start basic gmod() syntax looks like : graphical representation, can copy code Decision Twigs generate twigs: explanation twig : decisions(\"StandardOfCare\", \"StrategyA\"): define first twig decision two strategies involved: StandardOfCare StrategyA names: H healthy, S sick D dead. init_probs initial probabilities, optional max_cycle_in_states defines maximum number tunnel states per state. option omitted , function uses default 1. event = \"only_event\": defines event name. event must unique name can referenced events’s probability statements payoff equations described . scenarios = c(\"get_sick\", \"die\", \"stay\"): defines event scenarios: event can one : getting sick, dying staying current state. probs = c(pGetSick(state), pDie(decision, state), Inf)): probabilities correspondign scenarios occuring. powerful feature gmod allows probabilities conditional model components. define probability only_event==get_sick calling pGetSick(state) dependent state. Similarly, probability only_event==die defined calling pDie(decision, state) tell gmod dependent state decision. pGetSick pDie user-defined functions describe . Inf used tell gmod compute complementary probability probability staying state: (.e., 1-pGetSick(state)-pDie(state)) reduce amount typing needed. outcomes = c(\"S\", \"D\", \"curr_state\"): defines outcomes one event values. getting sick ends S state, dying ends D state, staying return whichever state cohort using special keyword \"curr_state\". payoffs(cost = cost(decision, state)): defines single payoff . cost payoff dependent state decision. one payoff can described , single payoff twig allowed. , similar probs argument can function model components, decision, state, cycles, events, tunnels, …etc","code":"mygmod <- gmod() +    decisions(\"StandardOfCare\", \"StrategyA\") +    states(names = c(\"H\", \"S\", \"D\"), init_probs = c(1,0,0)) +    event(name = \"only_event\",           scenarios = c(\"get_sick\", \"die\", \"stay\"),          probs = c(pGetSick(state), pDie(decision, state), Inf),          outcomes = c(\"S\", \"D\", \"curr_state\")) +     payoffs(cost = compute_cost(decision, state))"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"user-defined-functions-for-probabilities-and-payoffs","dir":"Articles","previous_headings":"A minimal example","what":"User-defined functions for probabilities and payoffs","title":"M0 gmod: getting started with building Markov models","text":"section, define three functions: pGetSick, pDie cost use event_mapping payoffs() layers : pGetSick simple function single else statement. Probability getting sick 0.1 one Healthy, otherwise 0. pDie function bothe decision state. Probability death 0.01 Healthy, 0.02 sick (+TreatmentA), 0.05 Sick+StandardOfCare, 0 already dead. compute_cost calculates cost disease combining cost state $1000 Healthy, $5000 sick $0 Dead. addition, computes cost decision additional $2000 one receives TreatmentA compared standard care. functions get complex, recommended test make sure return outcomes possible combinations states decisions input arguments. example, simple code tests functions possible combinations decisions states. Evaluate functions functions seem outputting correct numbers. switch similar else, can compact multiple else statements.","code":"pGetSick <- function(state){   if(state==\"H\") 0.1 else 0 }  pDie <- function(decision, state){   switch(state, \"H\"=0.01,           \"S\"= if (decision==\"StrategyA\") 0.02 else 0.05,           \"D\"=0) }  compute_cost <- function(decision, state){   cost_state <- switch(state, \"H\"=1000, \"S\"=5000, \"D\"=0)   cost_decision <- if(decision==\"StrategyA\" & state==\"S\") 2000 else 0   cost_state+cost_decision } gmod_expand_functions(mygmod) #> Note: The dataset  df_compute_cost  created for function  compute_cost . #> Note: The dataset  df_pDie  created for function  pDie . #> Note: The dataset  df_pGetSick  created for function  pGetSick . head(df_pDie) #>         decision state pDie #> 1 StandardOfCare     H 0.01 #> 2      StrategyA     H 0.01 #> 3 StandardOfCare     S 0.05 #> 4      StrategyA     S 0.02 #> 5 StandardOfCare     D 0.00 #> 6      StrategyA     D 0.00 for (decision in c(\"StandardOfCare\", \"StrategyA\")){   for (state in c(\"H\", \"S\", \"D\")){     cat(\"decision:\", decision, \" state:\", state, \" pGetSick:\", pGetSick(state),          \" pDie:\", pDie(decision, state), \" cost:\", compute_cost(decision, state), \"\\n\")   } } #> decision: StandardOfCare  state: H  pGetSick: 0.1  pDie: 0.01  cost: 1000  #> decision: StandardOfCare  state: S  pGetSick: 0  pDie: 0.05  cost: 5000  #> decision: StandardOfCare  state: D  pGetSick: 0  pDie: 0  cost: 0  #> decision: StrategyA  state: H  pGetSick: 0.1  pDie: 0.01  cost: 1000  #> decision: StrategyA  state: S  pGetSick: 0  pDie: 0.02  cost: 7000  #> decision: StrategyA  state: D  pGetSick: 0  pDie: 0  cost: 0"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"running-the-model","dir":"Articles","previous_headings":"A minimal example","what":"Running the model","title":"M0 gmod: getting started with building Markov models","text":"Now ingredients run model. First, need generate model function code create model_struc contains model equations formulae can examined, stated generated note, function also produces function representation Markov model. default name function my_markov_model. Let’s examine content two object. First, let’s check model structure examining content structure can helpful debug model examining individual layers formulae. example $model_equations returns probability cost formulae plain text. can evaluated calling directly needed. example, want know probability staying Healthy state can just copy content probs column corresponding curr_state evaluate corresponding parameters: Next, can also examine contents my_markov_model function generates text. generated code build introductory advanced Markov tutorials Medical Decision Making. information, please refer tutorials. Now, let’s run model function generate summary results running model 5 cycles computing cumulative cost cohort. can also retrieve components Markov model run, Markov trace shows proportion cohort states 5 cycles.","code":"model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) model_struc # returns the model structure including the formulae before evaluation #> $is_cycle_dep #> [1] FALSE #>  #> $decisions #> [1] \"StandardOfCare\" \"StrategyA\"      #>  #> $n_decisions #> [1] 2 #>  #> $states #> [1] \"H\" \"S\" \"D\" #>  #> $n_states #> [1] 3 #>  #> $states_expanded #> [1] \"H\" \"S\" \"D\" #>  #> $n_states_expanded #> [1] 3 #>  #> $n_events #> [1] 1 #>  #> $p0 #> $p0$StandardOfCare #> H S D  #> 1 0 0  #>  #> $p0$StrategyA #> H S D  #> 1 0 0  #>  #>  #> $events #> [1] \"only_event\" #>  #> $events_df #>    type      event   values                                    probs   outcomes #> 1 event only_event get_sick                          pGetSick(state)          S #> 2 event only_event      die                     pDie(decision,state)          D #> 3 event only_event     stay 1-(pGetSick(state)+pDie(decision,state)) curr_state #>   id #> 1  1 #> 2  2 #> 3  3 #>  #> $payoffs #> $payoffs$cost #> compute_cost(decision, state) #>  #>  #> $payoff_names #> [1] \"cost\" #>  #> $n_payoffs #> [1] 1 #>  #> $discounts #> cost  #>    0  #>  #> $model_equations #> # A tibble: 3 × 3 #>   dest       probs                                      cost                     #>   <chr>      <chr>                                      <chr>                    #> 1 D          (pDie(decision,state))                     (pDie(decision,state))*… #> 2 S          (pGetSick(state))                          (pGetSick(state))*compu… #> 3 curr_state (1-(pGetSick(state)+pDie(decision,state))) (1-(pGetSick(state)+pDi… #>  #> attr(,\"class\") #> [1] \"gmod_markov\" (1-(pGetSick(state=\"H\")+pDie(decision=\"StandardOfCare\",state=\"H\")))  #> [1] 0.89 my_markov_model #without parenthesis returns the function text #> function (model_struc, params = NULL, return_transition_prob = FALSE,  #>     return_state_payoffs = FALSE, return_trace = FALSE, return_cycle_payoffs = FALSE,  #>     return_payoff_summary = TRUE)  #> { #>     if (!is.null(params))  #>         list2env(params, envir = .GlobalEnv) #>     decisions <- model_struc$decisions #>     tunnel_lengths <- model_struc$tunnel_lengths #>     tunnel_lengths[is.infinite(tunnel_lengths)] <- n_cycles #>     n_decisions <- model_struc$n_decisions #>     cycles <- 1:n_cycles #>     states_expanded <- model_struc$states_expanded #>     n_states_expanded <- model_struc$n_states_expanded #>     payoff_names <- model_struc$payoff_names #>     n_payoffs <- model_struc$n_payoffs #>     discounts <- eval(model_struc$discounts) #>     P <- array(0, dim = c(n_states_expanded, n_states_expanded,  #>         n_decisions), dimnames = list(states_expanded, states_expanded,  #>         decisions)) #>     state_payoffs <- array(0, dim = c(n_states_expanded, n_decisions,  #>         n_payoffs), dimnames = list(states_expanded, decisions,  #>         payoff_names)) #>     dest <- \"D\" #>     for (decision in decisions) { #>         for (state_expanded in states_expanded) { #>             state <- state_expanded #>             P[state_expanded, dest, decision] <- (pDie(decision,  #>                 state)) #>         } #>     } #>     dest <- \"S\" #>     for (state_expanded in states_expanded) { #>         state <- state_expanded #>         P[state_expanded, dest, ] <- (pGetSick(state)) #>     } #>     dest <- \"curr_state\" #>     for (decision in decisions) { #>         for (state_expanded in states_expanded) { #>             state <- state_expanded #>             dest <- state_expanded #>             P[state_expanded, dest, decision] <- P[state_expanded,  #>                 dest, decision] + (1 - (pGetSick(state) + pDie(decision,  #>                 state))) #>         } #>     } #>     for (decision in decisions) { #>         for (state_expanded in states_expanded) { #>             state <- state_expanded #>             state_payoffs[state_expanded, decision, \"cost\"] <- (pDie(decision,  #>                 state)) * compute_cost(decision, state) + (pGetSick(state)) *  #>                 compute_cost(decision, state) + (1 - (pGetSick(state) +  #>                 pDie(decision, state))) * compute_cost(decision,  #>                 state) #>         } #>     } #>     Trace <- array(NA, dim = c(n_cycles, n_states_expanded, n_decisions),  #>         dimnames = list(cycles, states_expanded, decisions)) #>     cycle_payoffs <- array(0, dim = c(n_cycles, n_states_expanded,  #>         n_decisions, n_payoffs), dimnames = list(cycles, states_expanded,  #>         decisions, payoff_names)) #>     for (decision in decisions) { #>         Trace[1, , decision] <- model_struc$p0[[decision]] #>         for (i in 2:n_cycles) { #>             P_temp <- P[, , decision] #>             Trace[i, , decision] <- Trace[i - 1, , decision] %*%  #>                 P_temp #>         } #>     } #>     cycle_ones <- matrix(1, nrow = n_cycles, ncol = 1) #>     state_ones <- matrix(1, nrow = 1, ncol = n_states_expanded) #>     summary_payoffs <- matrix(0, nrow = n_decisions, ncol = n_payoffs,  #>         dimnames = list(decisions, payoff_names)) #>     for (decision in decisions) { #>         for (payoff_name in payoff_names) { #>             mat_discounts <- matrix(1/(1 + discounts[payoff_name])^(cycles -  #>                 1), ncol = 1) %*% state_ones #>             Payoff_temp <- cycle_ones %*% state_payoffs[, decision,  #>                 payoff_name] #>             cycle_payoffs[, , decision, payoff_name] <- Trace[,  #>                 , decision] * Payoff_temp * mat_discounts #>             summary_payoffs[decision, payoff_name] <- sum(cycle_payoffs[,  #>                 , decision, payoff_name]) #>         } #>     } #>     model_results <- list() #>     if (return_transition_prob)  #>         model_results$P <- P #>     if (return_state_payoffs)  #>         model_results$state_payoffs <- state_payoffs #>     if (return_trace)  #>         model_results$Trace <- Trace #>     if (return_cycle_payoffs)  #>         model_results$cycle_payoffs <- cycle_payoffs #>     if (return_payoff_summary)  #>         model_results$summary_payoffs <- summary_payoffs #>     return(model_results) #> } #> <environment: 0x10b36d3f8> n_cycles <- 10 my_markov_model(model_struc) #> $summary_payoffs #>                    cost #> StandardOfCare 20998.32 #> StrategyA      28735.17 model_results <- my_markov_model(model_struc, return_trace = T) model_results$Trace #> , , StandardOfCare #>  #>            H         S          D #> 1  1.0000000 0.0000000 0.00000000 #> 2  0.8900000 0.1000000 0.01000000 #> 3  0.7921000 0.1840000 0.02390000 #> 4  0.7049690 0.2540100 0.04102100 #> 5  0.6274224 0.3118064 0.06077119 #> 6  0.5584059 0.3589583 0.08263573 #> 7  0.4969813 0.3968510 0.10616771 #> 8  0.4423133 0.4267066 0.13098007 #> 9  0.3936589 0.4496026 0.15673853 #> 10 0.3503564 0.4664883 0.18315525 #>  #> , , StrategyA #>  #>            H         S          D #> 1  1.0000000 0.0000000 0.00000000 #> 2  0.8900000 0.1000000 0.01000000 #> 3  0.7921000 0.1870000 0.02090000 #> 4  0.7049690 0.2624700 0.03256100 #> 5  0.6274224 0.3277175 0.04486009 #> 6  0.5584059 0.3839054 0.05768866 #> 7  0.4969813 0.4320679 0.07095083 #> 8  0.4423133 0.4731246 0.08456200 #> 9  0.3936589 0.5078935 0.09844763 #> 10 0.3503564 0.5371015 0.11254209"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"changing-basic-features-of-our-markov-model","dir":"Articles","previous_headings":"","what":"changing basic features of our Markov model:","title":"M0 gmod: getting started with building Markov models","text":"start modifying basic features markov model. explore change number Markov cycles, initial probabilities, discount rates.","code":""},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"changing-the-number-of-cycles","dir":"Articles","previous_headings":"changing basic features of our Markov model:","what":"changing the number of cycles:","title":"M0 gmod: getting started with building Markov models","text":"Changing number Markov cycles straightforward changing n_cycles parameter gmod function. example, change number cycles 5 2:","code":"mygmod <- gmod()"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"changing-initial-probabilities","dir":"Articles","previous_headings":"changing basic features of our Markov model:","what":"changing initial probabilities:","title":"M0 gmod: getting started with building Markov models","text":"can set initial probabilities various ways. time start cohort health state. showed set everyone starts Healthy state. However, can distribution want. example, can define starting probabilities states. , can even use combination variables Inf placeholder complementary probabilities. run model updated probabilities, need add new init_prob layer gmod code. can see first line Trace H=0.7, S=0.2 D=0.1. gmod tries check composition probability vector returns error inconsistencies.","code":"states(names = c(\"H\",\"S\",\"D\"), init_probs = c(1,0,0)) #> [[1]] #> [[1]]$type #> [1] \"states\" #>  #> [[1]]$states #> [1] \"H\" \"S\" \"D\" #>  #>  #> [[2]] #> [[2]]$type #> [1] \"initial_prob\" #>  #> [[2]]$states #> [1] \"H\" \"S\" \"D\" #>  #> [[2]]$probs #> [1] 1 0 0 states(names = c(\"H\",\"S\",\"D\"), init_probs = c(0.7,0.2,0.1)) #> [[1]] #> [[1]]$type #> [1] \"states\" #>  #> [[1]]$states #> [1] \"H\" \"S\" \"D\" #>  #>  #> [[2]] #> [[2]]$type #> [1] \"initial_prob\" #>  #> [[2]]$states #> [1] \"H\" \"S\" \"D\" #>  #> [[2]]$probs #> [1] 0.7 0.2 0.1 pH0 <- 0.7 pS0 <- 0.2 states(names = c(\"H\",\"S\",\"D\"), init_probs = c(pH0, pS0, Inf)) #> [[1]] #> [[1]]$type #> [1] \"states\" #>  #> [[1]]$states #> [1] \"H\" \"S\" \"D\" #>  #>  #> [[2]] #> [[2]]$type #> [1] \"initial_prob\" #>  #> [[2]]$states #> [1] \"H\" \"S\" \"D\" #>  #> [[2]]$probs #> [1] 0.7 0.2 Inf mygmod <- gmod() +    decisions(\"StandardOfCare\", \"StrategyA\") +    states(names = c(\"H\",\"S\",\"D\"), init_probs = c(pH0, pS0, Inf)) +    event(name = \"only_event\",                 scenarios = c(\"get_sick\", \"die\", \"stay\"),                probs = c(pGetSick(state), pDie(decision, state), Inf),                outcomes = c(\"S\", \"D\", \"curr_state\")) +     payoffs(cost = compute_cost(decision, state))    # creating the updated function and evaluating it model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) model_results <- my_markov_model(model_struc, return_trace = T) model_results$Trace #> , , StandardOfCare #>  #>            H         S         D #> 1  0.7000000 0.2000000 0.1000000 #> 2  0.6230000 0.2600000 0.1170000 #> 3  0.5544700 0.3093000 0.1362300 #> 4  0.4934783 0.3492820 0.1572397 #> 5  0.4391957 0.3811657 0.1796386 #> 6  0.3908842 0.4060270 0.2030888 #> 7  0.3478869 0.4248141 0.2272990 #> 8  0.3096193 0.4383621 0.2520186 #> 9  0.2755612 0.4474059 0.2770329 #> 10 0.2452495 0.4525917 0.3021588 #>  #> , , StrategyA #>  #>            H         S         D #> 1  0.7000000 0.2000000 0.1000000 #> 2  0.6230000 0.2660000 0.1110000 #> 3  0.5544700 0.3229800 0.1225500 #> 4  0.4934783 0.3719674 0.1345543 #> 5  0.4391957 0.4138759 0.1469284 #> 6  0.3908842 0.4495179 0.1595979 #> 7  0.3478869 0.4796160 0.1724971 #> 8  0.3096193 0.5048124 0.1855683 #> 9  0.2755612 0.5256780 0.1987607 #> 10 0.2452495 0.5427206 0.2120299"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"changing-the-discount-rates","dir":"Articles","previous_headings":"changing basic features of our Markov model:","what":"changing the discount rates","title":"M0 gmod: getting started with building Markov models","text":"Changing discount rate similar setting initial probabilities. can set payoffs. illustrate, add additional payoff (effectiveness), use discount rate 3% per cycle costs utilities.","code":"mygmod <- gmod() +    decisions(\"StandardOfCare\", \"StrategyA\") +    states(names = c(\"H\", \"S\", \"D\"), init_probs = c(1,0,0)) +   event(name = \"only_event\",           scenarios = c(\"get_sick\", \"die\", \"stay\"),          probs = c(pGetSick(state), pDie(decision, state), Inf),          outcomes = c(\"S\", \"D\", \"curr_state\")) +     payoffs(cost = compute_cost(decision, state),            effectiveness = compute_effectiveness(state),            discount_rates = c(0.03, 0.03))  # define the effectiveness function, the rest of the function will be just like before compute_effectiveness <- function(state){   switch(state, \"H\"=1, \"S\"=0.7, \"D\"=0) }  # creating the updated function and evaluating it model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) # we look at the cycle payoffs which apply the discounts to the cycle payoffs. my_markov_model(model_struc, return_cycle_payoffs=TRUE) #> $cycle_payoffs #> , , StandardOfCare, cost #>  #>            H         S D #> 1  1000.0000    0.0000 0 #> 2   864.0777  485.4369 0 #> 3   746.6302  867.1882 0 #> 4   645.1465 1162.2757 0 #> 5   557.4567 1385.1797 0 #> 6   481.6859 1548.2030 0 #> 7   416.2140 1661.7823 0 #> 8   359.6412 1734.7575 0 #> 9   310.7580 1774.6022 0 #> 10  268.5190 1787.6224 0 #>  #> , , StrategyA, cost #>  #>            H         S D #> 1  1000.0000    0.0000 0 #> 2   864.0777  679.6117 0 #> 3   746.6302 1233.8580 0 #> 4   645.1465 1681.3806 0 #> 5   557.4567 2038.2093 0 #> 6   481.6859 2318.1211 0 #> 7   416.2140 2532.9503 0 #> 8   359.6412 2692.8555 0 #> 9   310.7580 2806.5507 0 #> 10  268.5190 2881.5051 0 #>  #> , , StandardOfCare, effectiveness #>  #>            H          S D #> 1  1.0000000 0.00000000 0 #> 2  0.8640777 0.06796117 0 #> 3  0.7466302 0.12140635 0 #> 4  0.6451465 0.16271859 0 #> 5  0.5574567 0.19392516 0 #> 6  0.4816859 0.21674842 0 #> 7  0.4162140 0.23264952 0 #> 8  0.3596412 0.24286605 0 #> 9  0.3107580 0.24844430 0 #> 10 0.2685190 0.25026713 0 #>  #> , , StrategyA, effectiveness #>  #>            H          S D #> 1  1.0000000 0.00000000 0 #> 2  0.8640777 0.06796117 0 #> 3  0.7466302 0.12338580 0 #> 4  0.6451465 0.16813806 0 #> 5  0.5574567 0.20382093 0 #> 6  0.4816859 0.23181211 0 #> 7  0.4162140 0.25329503 0 #> 8  0.3596412 0.26928555 0 #> 9  0.3107580 0.28065507 0 #> 10 0.2685190 0.28815051 0 #>  #>  #> $summary_payoffs #>                    cost effectiveness #> StandardOfCare 18057.18      7.387116 #> StrategyA      24515.17      7.536633"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"transition-probability-and-payoffs-conditional-on-markov-cycle","dir":"Articles","previous_headings":"","what":"Transition probability and payoffs conditional on Markov cycle:","title":"M0 gmod: getting started with building Markov models","text":"Sometimes want probability transition one state another, payoff’s value depend cohort’s age. can achieve using special variable cycle transition probabilities payoffs. code shows previous code single block modify probability death cost payoff depend cycle. See can spot difference: course, need add variable cycle function definitions pDie compute_cost also remember add function calls gmod function. illustration assume pDie cost states increased linear function Markov cycles, 1X, 2X, …, 5X cycles 1 5, respectively. Let’s check first see functions correct, run model inspect outputs. Now can examine impact model results","code":"mygmod <- gmod() +    decisions(\"StandardOfCare\", \"StrategyA\") +    states(names = c(\"H\", \"S\", \"D\"), init_probs = c(1,0,0)) +   event(name = \"only_event\",                 scenarios = c(\"get_sick\", \"die\", \"stay\"),                probs = c(pGetSick(state), pDie(decision, state, cycle), Inf),                outcomes = c(\"S\", \"D\", \"curr_state\")) +     payoffs(cost = compute_cost(decision, state, cycle))  pGetSick <- function(state){   if(state==\"H\") 0.1 else 0 }  pDie <- function(decision, state, cycle){   switch(state, \"H\"=0.01,         \"S\"= if (decision==\"StrategyA\") 0.02 else 0.05,         \"D\"=0) * cycle }  compute_cost <- function(decision, state, cycle){   cost_state <- switch(state, \"H\"=1000, \"S\"=5000, \"D\"=0) * cycle   cost_decision <- if(decision==\"StrategyA\" & state==\"S\") 2000 else 0   cost_state+cost_decision }  model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) for (decision in c(\"StandardOfCare\", \"StrategyA\")){   for (state in c(\"H\", \"S\", \"D\")){     for (cycle in 1:2){ # just print the first two cycles           cat(\"decision:\", decision, \" state:\", state, \" cycle:\", cycle, \" pGetSick:\", pGetSick(state),          \" pDie:\", pDie(decision, state, cycle), \" cost:\", compute_cost(decision, state, cycle), \"\\n\")     }   } } #> decision: StandardOfCare  state: H  cycle: 1  pGetSick: 0.1  pDie: 0.01  cost: 1000  #> decision: StandardOfCare  state: H  cycle: 2  pGetSick: 0.1  pDie: 0.02  cost: 2000  #> decision: StandardOfCare  state: S  cycle: 1  pGetSick: 0  pDie: 0.05  cost: 5000  #> decision: StandardOfCare  state: S  cycle: 2  pGetSick: 0  pDie: 0.1  cost: 10000  #> decision: StandardOfCare  state: D  cycle: 1  pGetSick: 0  pDie: 0  cost: 0  #> decision: StandardOfCare  state: D  cycle: 2  pGetSick: 0  pDie: 0  cost: 0  #> decision: StrategyA  state: H  cycle: 1  pGetSick: 0.1  pDie: 0.01  cost: 1000  #> decision: StrategyA  state: H  cycle: 2  pGetSick: 0.1  pDie: 0.02  cost: 2000  #> decision: StrategyA  state: S  cycle: 1  pGetSick: 0  pDie: 0.02  cost: 7000  #> decision: StrategyA  state: S  cycle: 2  pGetSick: 0  pDie: 0.04  cost: 12000  #> decision: StrategyA  state: D  cycle: 1  pGetSick: 0  pDie: 0  cost: 0  #> decision: StrategyA  state: D  cycle: 2  pGetSick: 0  pDie: 0  cost: 0 model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) my_markov_model(model_struc) #> $summary_payoffs #>                     cost #> StandardOfCare  64950.86 #> StrategyA      100340.56"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"transition-probabilty-and-payoff-dependency-on-the-number-of-cycles-in-a-state-tunnel-states-or-state-residency","dir":"Articles","previous_headings":"Transition probability and payoffs conditional on Markov cycle:","what":"Transition probabilty and payoff dependency on the number of cycles in a state (tunnel states or state residency):","title":"M0 gmod: getting started with building Markov models","text":"Sometimes different situation want keep track long cohort particular state model history disease. usually creating called tunnel states expanding number states example S1, S2, …, etc. transition S2 possible S1 S3 S2, … etc. show pDie compute_cost. interested history 3 years. - can spot difference compared minimal model? quite simple add tunnel dependency adding cycle_in_state variable. IMPORTANT: model least state time dependency, cycle_in_state variable becomes avaialble states. States defined tunnels() layer always return cycle_in_state=1 Similar , assume probability death linear function number cycles S. cost, also assume longer stay S higher cost - also linearly related. important change add tunnels() layer specifying states residency time history dependency. assume S time dependency 3 cycles . can expanded multiple states various tunnel lengths. Let’s check first see functions correct, run model inspect outputs. Now can examine impact model results Let’s examine transition probability matrix structure tunnel state returns list two 5x5 matrices transition probabilities two strategies. matrices describe probability transition origin state (row) destination state (column). Now notice S replaced S_tnl1, S_tnl2 S_tnl3 indicating three cycles S separate states. Also notice special way transitions occur among states. .e., tunnel state goes next one, never back stay state except last state tunnel, S_tnl3. Since made probability death function tunnel state, can see probabiltiy death StandardOfCare (last column) S_tnl1 = 0.05, S_tnl2=0.10 S_tnl3=0.15 specified function. Similarly, probability death StrategyA also incrases linearly 0.02 S_tnl1, 0.04 S_tnl2 0.06 S_tnl3. , let’s examine cycle payoffs. can see year S, cost increases $5000.","code":"mygmod <- gmod() +    decisions(\"StandardOfCare\", \"StrategyA\") +   states(names = c(\"H\", \"S\", \"D\"), init_probs = c(1,0,0), max_cycle_in_states = c(1,3,1)) +  #   event(name = \"only_event\",                 scenarios = c(\"get_sick\", \"die\", \"stay\"),                probs = c(pGetSick(state), pDie(decision, state, cycle_in_state), Inf),                outcomes = c(\"S\", \"D\", \"curr_state\")) + #   payoffs(cost = compute_cost(decision, state, cycle_in_state)) #  pGetSick <- function(state){   if(state==\"H\") 0.1 else 0 }  pDie <- function(decision, state, cycle_in_state){ #   switch(state, \"H\"=0.01,         \"S\"= cycle_in_state * if (decision==\"StrategyA\") 0.02 else 0.05,         \"D\"=0)  }  compute_cost <- function(decision, state, cycle_in_state){ #   cost_state <- switch(state, \"H\"=1000, \"S\"=5000 * cycle_in_state, \"D\"=0)  #   cost_decision <- if(decision==\"StrategyA\" & state==\"S\") 2000 else 0   cost_state+cost_decision }  model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) for (decision in c(\"StandardOfCare\", \"StrategyA\")){   for (state in c(\"H\", \"S\", \"D\")){     for (cycle_in_state in 1:2){ # just print the first two cycles           cat(\"decision:\", decision, \" state:\", state, \" cycle_in_state:\", cycle_in_state, \" pGetSick:\", pGetSick(state),          \" pDie:\", pDie(decision, state, cycle_in_state), \" cost:\", compute_cost(decision, state, cycle_in_state), \"\\n\")     }   } } #> decision: StandardOfCare  state: H  cycle_in_state: 1  pGetSick: 0.1  pDie: 0.01  cost: 1000  #> decision: StandardOfCare  state: H  cycle_in_state: 2  pGetSick: 0.1  pDie: 0.01  cost: 1000  #> decision: StandardOfCare  state: S  cycle_in_state: 1  pGetSick: 0  pDie: 0.05  cost: 5000  #> decision: StandardOfCare  state: S  cycle_in_state: 2  pGetSick: 0  pDie: 0.1  cost: 10000  #> decision: StandardOfCare  state: D  cycle_in_state: 1  pGetSick: 0  pDie: 0  cost: 0  #> decision: StandardOfCare  state: D  cycle_in_state: 2  pGetSick: 0  pDie: 0  cost: 0  #> decision: StrategyA  state: H  cycle_in_state: 1  pGetSick: 0.1  pDie: 0.01  cost: 1000  #> decision: StrategyA  state: H  cycle_in_state: 2  pGetSick: 0.1  pDie: 0.01  cost: 1000  #> decision: StrategyA  state: S  cycle_in_state: 1  pGetSick: 0  pDie: 0.02  cost: 7000  #> decision: StrategyA  state: S  cycle_in_state: 2  pGetSick: 0  pDie: 0.04  cost: 12000  #> decision: StrategyA  state: D  cycle_in_state: 1  pGetSick: 0  pDie: 0  cost: 0  #> decision: StrategyA  state: D  cycle_in_state: 2  pGetSick: 0  pDie: 0  cost: 0 model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) model_results <- my_markov_model(model_struc, return_transition_prob = T, return_state_payoffs = T) model_results$P # shows transition probabilities to Death #> , , StandardOfCare #>  #>           H S_tnl1 S_tnl2 S_tnl3    D #> H      0.89    0.1   0.00   0.00 0.01 #> S_tnl1 0.00    0.0   0.95   0.00 0.05 #> S_tnl2 0.00    0.0   0.00   0.90 0.10 #> S_tnl3 0.00    0.0   0.00   0.85 0.15 #> D      0.00    0.0   0.00   0.00 1.00 #>  #> , , StrategyA #>  #>           H S_tnl1 S_tnl2 S_tnl3    D #> H      0.89    0.1   0.00   0.00 0.01 #> S_tnl1 0.00    0.0   0.98   0.00 0.02 #> S_tnl2 0.00    0.0   0.00   0.96 0.04 #> S_tnl3 0.00    0.0   0.00   0.94 0.06 #> D      0.00    0.0   0.00   0.00 1.00 model_results$state_payoffs # shows cycle payoffs of the Sick state #> , , cost #>  #>        StandardOfCare StrategyA #> H                1000      1000 #> S_tnl1           5000      7000 #> S_tnl2          10000     12000 #> S_tnl3          15000     17000 #> D                   0         0"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"multiple-events-","dir":"Articles","previous_headings":"","what":"Multiple Events.","title":"M0 gmod: getting started with building Markov models","text":"relatively easy add additional events Markov model. Please keep mind Events quite flexible central Grammar Modeling framework. users free make branching events, recommend use single linear sequence events, call previous event values make sequence apply decisions states. example, event doesn’t happen particular decision (e.g., getting side effect), one can make get_side_effect event function decision, non-zero probability particular treatment. Grammer Modeling designed aroudn concept single sequence events makes code concise easier manage. slightly modify minimal example converting Sick state event. Assume Sick acute disease takes days rather full cycle. sequence events get_sick followed die. Sick longer state, use two health states Alive Dead show probability death can function event get_sick occuring event die. addition, show cost can also function value sick_event. also look one strategy “StandardOfCare simplify illustration. Notice now two sequential events. first event get_sick, second one die. get_sick doesn’t much cohort gets sick , face next event die. Next, show make probabilit death function event get_sick also make cost also function event.","code":"mygmod <- gmod() +    decisions(\"StandardOfCare\") +    states(names = c(\"Alive\", \"Dead\"), init_probs = c(1,0)) +    event(name = \"get_sick\",                 scenarios = c(TRUE, FALSE),                probs = c(0.05, Inf),                outcomes = c(\"die\", \"die\")) +     event(name = \"die\",                 scenarios = c(TRUE, FALSE),                probs = c(pDie(state), Inf),                outcomes = c(\"Dead\", \"curr_state\")) +     payoffs(cost = compute_cost(state))  pDie <- function(state){   # if the cohort gets sick, the probability of death = 0.01 otherwise it is 0.1   switch(state, \"Alive\"=0.01,                   \"Dead\"=0) }  compute_cost <- function(state){   cost_state <- switch(state, \"Alive\"=1000, \"Dead\"=0)   # add 2000 if someone in the Alive state gets sick   cost_state }  model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) my_markov_model(model_struc,return_transition_prob=TRUE,return_state_payoffs=TRUE,return_trace=TRUE,return_cycle_payoffs=TRUE,return_payoff_summary=TRUE) #> $P #> , , StandardOfCare #>  #>       Alive Dead #> Alive  0.99 0.01 #> Dead   0.00 1.00 #>  #>  #> $state_payoffs #> , , cost #>  #>       StandardOfCare #> Alive           1000 #> Dead               0 #>  #>  #> $Trace #> , , StandardOfCare #>  #>        Alive       Dead #> 1  1.0000000 0.00000000 #> 2  0.9900000 0.01000000 #> 3  0.9801000 0.01990000 #> 4  0.9702990 0.02970100 #> 5  0.9605960 0.03940399 #> 6  0.9509900 0.04900995 #> 7  0.9414801 0.05851985 #> 8  0.9320653 0.06793465 #> 9  0.9227447 0.07725531 #> 10 0.9135172 0.08648275 #>  #>  #> $cycle_payoffs #> , , StandardOfCare, cost #>  #>        Alive Dead #> 1  1000.0000    0 #> 2   990.0000    0 #> 3   980.1000    0 #> 4   970.2990    0 #> 5   960.5960    0 #> 6   950.9900    0 #> 7   941.4801    0 #> 8   932.0653    0 #> 9   922.7447    0 #> 10  913.5172    0 #>  #>  #> $summary_payoffs #>                    cost #> StandardOfCare 9561.792"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"transition-and-payoff-dependent-on-prior-events","dir":"Articles","previous_headings":"","what":"Transition and Payoff dependent on prior events","title":"M0 gmod: getting started with building Markov models","text":"previous section, illustrated add multiple sequential events. gmod can also use prior events influence transition probabilities downstream payoffs. can particularly important put events single sequence across decisions states. Traditional models often duplicate (copy clone) events creates nested branching problem can difficult manage troubleshoot. advantage able refer event value ability associate payoffs events. often referred transitional rewards payoffs payoffs occur event occurs. payoffs quite different state payoffs state payoffs associated spending time states compared event (transitional) payoffs associated events considered instantaneous happens portion cohort residing state. modify previous example making probability death function event get_sick occurring upstream. addition, show cost can also function value sick_event. also look one strategy “StandardOfCare simplify illustration. Notice now two sequential events. first event die, second one get_sick. Now, die=TRUE, cohort moves state D, D=FALSE, cohort moves next event get_sick. , get_sick=TRUE, cohort moves state S, , stay current state. rest user-functions can stay . show use prior events influence probability transition payoffs. Now can examine impact model results","code":"mygmod <- gmod() +    decisions(\"StandardOfCare\") +    states(names = c(\"Alive\", \"Dead\"), init_probs = c(1,0)) +    event(name = \"get_sick\",                 scenarios = c(TRUE, FALSE),                probs = c(0.05, Inf),                outcomes = c(\"die\", \"die\")) +       event(name = \"die\",                 scenarios = c(TRUE, FALSE),                probs = c(pDie(state, get_sick), Inf),                outcomes = c(\"Dead\", \"curr_state\")) +     payoffs(cost = compute_cost(state, get_sick))  pDie <- function(state, get_sick){   # if the cohort gets sick, the probability of death = 0.01 otherwise it is 0.1   switch(state, \"Alive\"= if(get_sick==TRUE) 0.1 else 0.01,                   \"Dead\"=0) }  compute_cost <- function(state, get_sick){   cost_state <- switch(state, \"Alive\"=1000, \"Dead\"=0)   # add 2000 if someone in the Alive state gets sick   cost_get_sick <- if(get_sick==TRUE & state==\"Alive\") 2000 else 0   cost_state+cost_get_sick } for (state in c(\"Alive\", \"Dead\")){    for (get_sick in c(TRUE, FALSE)){ # just print the first two cycles          cat(\" state:\", state, \" get_sick:\", get_sick, #        \" pDie:\", pDie(state, get_sick), \" cost:\", compute_cost(state, get_sick), \"\\n\")    }  } #>  state: Alive  get_sick: TRUE  pDie: 0.1  cost: 3000  #>  state: Alive  get_sick: FALSE  pDie: 0.01  cost: 1000  #>  state: Dead  get_sick: TRUE  pDie: 0  cost: 0  #>  state: Dead  get_sick: FALSE  pDie: 0  cost: 0 model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) my_markov_model(model_struc,return_transition_prob=TRUE,return_state_payoffs=TRUE,return_trace=TRUE,return_cycle_payoffs=TRUE,return_payoff_summary=TRUE) #> $P #> , , StandardOfCare #>  #>        Alive   Dead #> Alive 0.9855 0.0145 #> Dead  0.0000 1.0000 #>  #>  #> $state_payoffs #> , , cost #>  #>       StandardOfCare #> Alive           1100 #> Dead               0 #>  #>  #> $Trace #> , , StandardOfCare #>  #>        Alive       Dead #> 1  1.0000000 0.00000000 #> 2  0.9855000 0.01450000 #> 3  0.9712103 0.02878975 #> 4  0.9571277 0.04287230 #> 5  0.9432493 0.05675065 #> 6  0.9295722 0.07042777 #> 7  0.9160934 0.08390656 #> 8  0.9028101 0.09718992 #> 9  0.8897193 0.11028066 #> 10 0.8768184 0.12318159 #>  #>  #> $cycle_payoffs #> , , StandardOfCare, cost #>  #>        Alive Dead #> 1  1100.0000    0 #> 2  1084.0500    0 #> 3  1068.3313    0 #> 4  1052.8405    0 #> 5  1037.5743    0 #> 6  1022.5295    0 #> 7  1007.7028    0 #> 8   993.0911    0 #> 9   978.6913    0 #> 10  964.5002    0 #>  #>  #> $summary_payoffs #>                    cost #> StandardOfCare 10309.31"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"running-our-model-with-other-parameter-values","dir":"Articles","previous_headings":"","what":"Running our model with other parameter values","title":"M0 gmod: getting started with building Markov models","text":"gmod allows using variables inside custom functions. values must defined global environment accessible within functions. illustrate use parameters, can begin creating new list (params) contains 4 parameters shown . functions replace values variable names use params list. example, use pDieSick params = 0.1, replace 0.1 used pDie function variable name pDieSick. variables. gmod allows passing parameter values list. values passed list replace parameter values global environment.","code":"params <- list(pDieSick = 0.1,                pDieNotSick = 0.01,                costAlive = 1000,                costGetSick = 2000)  mygmod <- gmod() +    decisions(\"StandardOfCare\") +    states(names = c(\"Alive\", \"Dead\"), init_probs = c(1,0)) +    event(name = \"get_sick\",                 scenarios = c(TRUE, FALSE),                probs = c(0.05, Inf),                outcomes = c(\"die\", \"die\")) +       event(name = \"die\",                 scenarios = c(TRUE, FALSE),                probs = c(pDie(state, get_sick), Inf),                outcomes = c(\"Dead\", \"curr_state\")) +     payoffs(cost = compute_cost(state, get_sick))  pDie <- function(state, get_sick){   # if the cohort gets sick, the probability of death = 0.01 otherwise it is 0.1   switch(state, \"Alive\"= if(get_sick==TRUE) pDieSick else pDieNotSick,                   \"Dead\"=0) }  compute_cost <- function(state, get_sick){   cost_state <- switch(state, \"Alive\"=costAlive, \"Dead\"=0)   # add 2000 if someone in the Alive state gets sick   cost_get_sick <- if(get_sick==TRUE & state==\"Alive\") costGetSick else 0   cost_state+cost_get_sick }  model_struc <- gmod_gen_model_function(mygmod) #> Warning in gmod_gen_model_function.gmod_markov(mygmod): Model function my_markov_model is generated. It can be run by calling it directly, for example this function returns the summary results: #> my_markov_model(model_struc,params,return_transition_prob=FALSE,return_state_payoffs=FALSE,return_trace=FALSE,return_cycle_payoffs=FALSE,return_payoff_summary=TRUE) my_markov_model(model_struc,params=params) #> $summary_payoffs #>                    cost #> StandardOfCare 10309.31"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"rerunnign-the-model-with-a-different-set-of-parameter-values","dir":"Articles","previous_headings":"Running our model with other parameter values","what":"Rerunnign the model with a different set of parameter values","title":"M0 gmod: getting started with building Markov models","text":"Now, can simply change values parameter list rerun model simply calling different parameter values. example, change value pDieSick 0.3 0.1, change costGetSick 10000 2000. able pass parameters list can helpful conduct analyses using gmod structure. example, want run probabilistic sensitivity analysis, deterministic analyses, value information, calibrate model.","code":"params <- list(pDieSick = 0.3, # was 0.1                pDieNotSick = 0.01,                costAlive = 1000,                 costGetSick = 10000) # was 2000 my_markov_model(model_struc,params=params) #> $summary_payoffs #>                   cost #> StandardOfCare 13449.8"},{"path":"/articles/M0_getting_started_markov_gmod.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary:","title":"M0 gmod: getting started with building Markov models","text":"Vignette went basic features gmod library building running Markov models. illustrated features one time, show define decisions, states, events, payoffs. addition, show change number cycles, discounting rates. Furthermore, show make transition probabilities payoffs function decisions, states cycles, number cycles state (tunnel) previous events. details gmod, please refer vignettes, mainly introductory advanced Markov model tutorial vignettes replicate anlayses published Medical Decision Making.","code":""},{"path":"/articles/M2_gmod_advanced_markov_tutorial.html","id":"simplified-version","dir":"Articles","previous_headings":"","what":"simplified version","title":"M2 Advanced Markov Tutorial for Time Dependent Markov Model","text":"removes probability paths 0, simplifies 1. , build gmod Markov model using gmod_build() function. output structure model including formulae. evaluate model, run gmod_evaluate() returns numerical outcomes. warning just indicates parameters passed, gmod uses values global environment. analyses, probabilistic sensitivity analysis (PSA), can pass parameters list param. can load individual outcomes interested . example, interested Markov Trace Standard Care treatment, can type: Similarly, can load summary outcomes costs utility strategies, :","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Hawre Jalal. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jalal H (2024). gmod: gmod creates evaluates decision health economic evaluation models using Grammer Modeling. R package version 0.0.1.0.","code":"@Manual{,   title = {gmod: gmod creates and evaluates decision and health economic evaluation models using the Grammer of Modeling},   author = {Hawre Jalal},   year = {2024},   note = {R package version 0.0.1.0}, }"},{"path":"/reference/decisions.html","id":null,"dir":"Reference","previous_headings":"","what":"Add discounts to a gmod Markov object — decisions","title":"Add discounts to a gmod Markov object — decisions","text":"Add discounts gmod Markov object","code":""},{"path":"/reference/decisions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add discounts to a gmod Markov object — decisions","text":"","code":"decisions(...)"},{"path":"/reference/decisions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add discounts to a gmod Markov object — decisions","text":"... decision names states names states expand lengths length tunnel state","code":""},{"path":"/reference/decisions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add discounts to a gmod Markov object — decisions","text":"gmod layer decision names gmod layer tunnels gmod layer decision names","code":""},{"path":[]},{"path":"/reference/event.html","id":null,"dir":"Reference","previous_headings":"","what":"Add event mapping — event","title":"Add event mapping — event","text":"Add event mapping","code":""},{"path":"/reference/event.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add event mapping — event","text":"","code":"event(name, scenarios, probs, outcomes)"},{"path":"/reference/event.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add event mapping — event","text":"name  scenarios  probs  outcomes","code":""},{"path":"/reference/event.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add event mapping — event","text":"gmod layer","code":""},{"path":[]},{"path":"/reference/gmod.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a new gmod — gmod","title":"Create a new gmod — gmod","text":"Create new gmod","code":""},{"path":"/reference/gmod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a new gmod — gmod","text":"","code":"gmod()"},{"path":"/reference/gmod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a new gmod — gmod","text":"model_type  n_cycles = 50","code":""},{"path":"/reference/gmod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a new gmod — gmod","text":"new gmod object","code":""},{"path":"/reference/gmod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a new gmod — gmod","text":"","code":"gmod(model_type = \"Markov\", n_cycles = 40) #> Error in gmod(model_type = \"Markov\", n_cycles = 40): unused arguments (model_type = \"Markov\", n_cycles = 40)"},{"path":"/reference/gmod_build.gmod_decision.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a decision tree structure — gmod_build.gmod_decision","title":"Build a decision tree structure — gmod_build.gmod_decision","text":"takes gmod model syntax returns gmod formula structure","code":""},{"path":"/reference/gmod_build.gmod_decision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a decision tree structure — gmod_build.gmod_decision","text":"","code":"# S3 method for gmod_decision gmod_build(gmod_obj, params = NULL, simplify = FALSE)"},{"path":"/reference/gmod_build.gmod_decision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a decision tree structure — gmod_build.gmod_decision","text":"gmod_obj","code":""},{"path":"/reference/gmod_build.gmod_decision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a decision tree structure — gmod_build.gmod_decision","text":"gmod structure containing formulae strings","code":""},{"path":"/reference/gmod_build.gmod_decision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build a decision tree structure — gmod_build.gmod_decision","text":"","code":"print(\"see vignettes(package = 'gmod')\")  #> [1] \"see vignettes(package = 'gmod')\""},{"path":"/reference/gmod_build.gmod_markov.html","id":null,"dir":"Reference","previous_headings":"","what":"Build a Markov model structure — gmod_build.gmod_markov","title":"Build a Markov model structure — gmod_build.gmod_markov","text":"takes gmod formula structure returns gmod numerical formula structure","code":""},{"path":"/reference/gmod_build.gmod_markov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build a Markov model structure — gmod_build.gmod_markov","text":"","code":"# S3 method for gmod_markov gmod_build(gmod_obj, params = NULL, simplify = FALSE)"},{"path":"/reference/gmod_build.gmod_markov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build a Markov model structure — gmod_build.gmod_markov","text":"gmod_obj","code":""},{"path":"/reference/gmod_build.gmod_markov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build a Markov model structure — gmod_build.gmod_markov","text":"gmod structure containing formulae strings","code":""},{"path":"/reference/gmod_build.gmod_markov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build a Markov model structure — gmod_build.gmod_markov","text":"","code":"print(\"see vignettes(package = 'gmod')\")  #> [1] \"see vignettes(package = 'gmod')\""},{"path":"/reference/gmod_build.html","id":null,"dir":"Reference","previous_headings":"","what":"Builds a Markov model — gmod_build","title":"Builds a Markov model — gmod_build","text":"Builds Markov model","code":""},{"path":"/reference/gmod_build.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Builds a Markov model — gmod_build","text":"","code":"gmod_build(x, ...)"},{"path":"/reference/gmod_build.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Builds a Markov model — gmod_build","text":"gmod_obj","code":""},{"path":"/reference/gmod_build.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Builds a Markov model — gmod_build","text":"gmod object containing equations Markov model","code":""},{"path":"/reference/gmod_build.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Builds a Markov model — gmod_build","text":"","code":"print(\"see vignettes(package = 'gmod')\")  #> [1] \"see vignettes(package = 'gmod')\""},{"path":"/reference/gmod_evaluate.gmod_decision.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs the decision tree — gmod_evaluate.gmod_decision","title":"Runs the decision tree — gmod_evaluate.gmod_decision","text":"runs decision model returns expected payoff values summary outcomes","code":""},{"path":"/reference/gmod_evaluate.gmod_decision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs the decision tree — gmod_evaluate.gmod_decision","text":"","code":"# S3 method for gmod_decision gmod_evaluate(model_struc, params = NULL)"},{"path":"/reference/gmod_evaluate.gmod_decision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs the decision tree — gmod_evaluate.gmod_decision","text":"model_num_struc matrix containing numerical gmod decision object gmod_parse() function","code":""},{"path":"/reference/gmod_evaluate.gmod_decision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs the decision tree — gmod_evaluate.gmod_decision","text":"gmod object","code":""},{"path":"/reference/gmod_evaluate.gmod_decision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs the decision tree — gmod_evaluate.gmod_decision","text":"","code":"print(\"see vignettes: vignettes(package='gmod')\") #> [1] \"see vignettes: vignettes(package='gmod')\""},{"path":"/reference/gmod_evaluate.gmod_markov.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs the markov model — gmod_evaluate.gmod_markov","title":"Runs the markov model — gmod_evaluate.gmod_markov","text":"runs markov model returns traces summary outcomes","code":""},{"path":"/reference/gmod_evaluate.gmod_markov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs the markov model — gmod_evaluate.gmod_markov","text":"","code":"# S3 method for gmod_markov gmod_evaluate(   model_struc,   model_function_name = \"my_markov_model\",   print_model_function = FALSE )"},{"path":"/reference/gmod_evaluate.gmod_markov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs the markov model — gmod_evaluate.gmod_markov","text":"model_num_struc matrix containing numerical gmod object gmod_parse() function","code":""},{"path":"/reference/gmod_evaluate.gmod_markov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs the markov model — gmod_evaluate.gmod_markov","text":"gmod object","code":""},{"path":"/reference/gmod_evaluate.gmod_markov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs the markov model — gmod_evaluate.gmod_markov","text":"","code":"print(\"see vignettes: vignettes(package='gmod')\") #> [1] \"see vignettes: vignettes(package='gmod')\""},{"path":"/reference/gmod_evaluate.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs a decision tree or Markov model — gmod_evaluate","title":"Runs a decision tree or Markov model — gmod_evaluate","text":"runs decision tree markov model returns outcomes either traces summary outcomes","code":""},{"path":"/reference/gmod_evaluate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs a decision tree or Markov model — gmod_evaluate","text":"","code":"gmod_evaluate(x, ...)"},{"path":"/reference/gmod_evaluate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs a decision tree or Markov model — gmod_evaluate","text":"model_num_struc matrix containing numerical gmod object gmod_parse() function","code":""},{"path":"/reference/gmod_evaluate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs a decision tree or Markov model — gmod_evaluate","text":"gmod object","code":""},{"path":"/reference/gmod_evaluate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs a decision tree or Markov model — gmod_evaluate","text":"","code":"print(\"see vignettes: vignettes(package='gmod')\") #> [1] \"see vignettes: vignettes(package='gmod')\""},{"path":"/reference/gmod_expand_functions.html","id":null,"dir":"Reference","previous_headings":"","what":"Title — gmod_expand_functions","title":"Title — gmod_expand_functions","text":"Title","code":""},{"path":"/reference/gmod_expand_functions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title — gmod_expand_functions","text":"","code":"gmod_expand_functions(gmod_obj, fun_names, excel_file_name = NULL)"},{"path":"/reference/gmod_expand_functions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title — gmod_expand_functions","text":"gmod_obj  fun_names  excel_file_name","code":""},{"path":"/reference/gmod_gen_model_function.gmod_decision.html","id":null,"dir":"Reference","previous_headings":"","what":"Title — gmod_gen_model_function.gmod_decision","title":"Title — gmod_gen_model_function.gmod_decision","text":"Title","code":""},{"path":"/reference/gmod_gen_model_function.gmod_decision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title — gmod_gen_model_function.gmod_decision","text":"","code":"# S3 method for gmod_decision gmod_gen_model_function(   model_struc,   model_function_name = \"my_decision_model\",   print_model_function = FALSE,   return_model_structure = TRUE )"},{"path":"/reference/gmod_gen_model_function.gmod_decision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title — gmod_gen_model_function.gmod_decision","text":"model_struc  model_function_name  print_model_function","code":""},{"path":"/reference/gmod_gen_model_function.gmod_decision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title — gmod_gen_model_function.gmod_decision","text":"model_struc generates model function code","code":""},{"path":"/reference/gmod_gen_model_function.gmod_decision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title — gmod_gen_model_function.gmod_decision","text":"","code":"print(\"see vignettes: vignettes(package='gmod')\") #> [1] \"see vignettes: vignettes(package='gmod')\""},{"path":"/reference/gmod_gen_model_function.gmod_markov.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs the markov model — gmod_gen_model_function.gmod_markov","title":"Runs the markov model — gmod_gen_model_function.gmod_markov","text":"runs markov model returns traces summary outcomes","code":""},{"path":"/reference/gmod_gen_model_function.gmod_markov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs the markov model — gmod_gen_model_function.gmod_markov","text":"","code":"# S3 method for gmod_markov gmod_gen_model_function(   mygmod,   model_function_name = \"my_markov_model\",   print_model_function = FALSE,   sparse = FALSE,   return_model_structure = TRUE )"},{"path":"/reference/gmod_gen_model_function.gmod_markov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs the markov model — gmod_gen_model_function.gmod_markov","text":"model_struc matrix containing numerical gmod object gmod_parse() function","code":""},{"path":"/reference/gmod_gen_model_function.gmod_markov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs the markov model — gmod_gen_model_function.gmod_markov","text":"model_struc generates model function code","code":""},{"path":"/reference/gmod_gen_model_function.gmod_markov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs the markov model — gmod_gen_model_function.gmod_markov","text":"","code":"print(\"see vignettes: vignettes(package='gmod')\") #> [1] \"see vignettes: vignettes(package='gmod')\""},{"path":"/reference/gmod_gen_model_function.html","id":null,"dir":"Reference","previous_headings":"","what":"Runs a decision tree or Markov model — gmod_gen_model_function","title":"Runs a decision tree or Markov model — gmod_gen_model_function","text":"runs decision tree markov model returns outcomes either traces summary outcomes","code":""},{"path":"/reference/gmod_gen_model_function.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Runs a decision tree or Markov model — gmod_gen_model_function","text":"","code":"gmod_gen_model_function(x, ...)"},{"path":"/reference/gmod_gen_model_function.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Runs a decision tree or Markov model — gmod_gen_model_function","text":"model_num_struc matrix containing numerical gmod object gmod_parse() function","code":""},{"path":"/reference/gmod_gen_model_function.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Runs a decision tree or Markov model — gmod_gen_model_function","text":"model_struc generates model function code","code":""},{"path":"/reference/gmod_gen_model_function.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Runs a decision tree or Markov model — gmod_gen_model_function","text":"","code":"print(\"see vignettes: vignettes(package='gmod')\") #> [1] \"see vignettes: vignettes(package='gmod')\""},{"path":"/reference/gmod_parse.gmod_decision.html","id":null,"dir":"Reference","previous_headings":"","what":"Parses a gmod Decision Tree object — gmod_parse.gmod_decision","title":"Parses a gmod Decision Tree object — gmod_parse.gmod_decision","text":"given gmod equations list parameters evaluates model equations returns numerical values","code":""},{"path":"/reference/gmod_parse.gmod_decision.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parses a gmod Decision Tree object — gmod_parse.gmod_decision","text":"","code":"# S3 method for gmod_decision gmod_parse(model_struc, params = NULL)"},{"path":"/reference/gmod_parse.gmod_decision.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parses a gmod Decision Tree object — gmod_parse.gmod_decision","text":"model_struc gmod representing model structure params parameter list containing model parameters","code":""},{"path":"/reference/gmod_parse.gmod_decision.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parses a gmod Decision Tree object — gmod_parse.gmod_decision","text":"model_num_struc","code":""},{"path":"/reference/gmod_parse.gmod_decision.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parses a gmod Decision Tree object — gmod_parse.gmod_decision","text":"","code":"print(\"See Vignettes\") #> [1] \"See Vignettes\""},{"path":"/reference/gmod_parse.gmod_markov.html","id":null,"dir":"Reference","previous_headings":"","what":"Parses a gmod Markov object — gmod_parse.gmod_markov","title":"Parses a gmod Markov object — gmod_parse.gmod_markov","text":"given gmod equations list parameters evaluates model equations returns numerical values","code":""},{"path":"/reference/gmod_parse.gmod_markov.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parses a gmod Markov object — gmod_parse.gmod_markov","text":"","code":"# S3 method for gmod_markov gmod_parse(model_struc, params = NULL)"},{"path":"/reference/gmod_parse.gmod_markov.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parses a gmod Markov object — gmod_parse.gmod_markov","text":"model_struc gmod representing model structure params parameter list containing model parameters","code":""},{"path":"/reference/gmod_parse.gmod_markov.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parses a gmod Markov object — gmod_parse.gmod_markov","text":"model_num_struc","code":""},{"path":"/reference/gmod_parse.gmod_markov.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parses a gmod Markov object — gmod_parse.gmod_markov","text":"","code":"print(\"See Vignettes\") #> [1] \"See Vignettes\""},{"path":"/reference/gmod_parse.html","id":null,"dir":"Reference","previous_headings":"","what":"Parses a gmod model formula structure — gmod_parse","title":"Parses a gmod model formula structure — gmod_parse","text":"parses string formulae computes numerical outcomes","code":""},{"path":"/reference/gmod_parse.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parses a gmod model formula structure — gmod_parse","text":"","code":"gmod_parse(x, ...)"},{"path":"/reference/gmod_parse.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parses a gmod model formula structure — gmod_parse","text":"gmod_obj gmod object containing equations Markov model params list containing model parameters","code":""},{"path":"/reference/gmod_parse.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parses a gmod model formula structure — gmod_parse","text":"nuemerical gmod object structure","code":""},{"path":"/reference/gmod_parse.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parses a gmod model formula structure — gmod_parse","text":"","code":"print(\"See Vignettes\") #> [1] \"See Vignettes\""},{"path":"/reference/payoffs.html","id":null,"dir":"Reference","previous_headings":"","what":"Add final_outcomes from a decision tree to a gmod — payoffs","title":"Add final_outcomes from a decision tree to a gmod — payoffs","text":"Add final_outcomes decision tree gmod","code":""},{"path":"/reference/payoffs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add final_outcomes from a decision tree to a gmod — payoffs","text":"","code":"payoffs(...)"},{"path":"/reference/payoffs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add final_outcomes from a decision tree to a gmod — payoffs","text":"... named list containing payoffs associated payoff functions","code":""},{"path":"/reference/payoffs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add final_outcomes from a decision tree to a gmod — payoffs","text":"gmod layer Decision final_outcome names gmod layer payoffs","code":""},{"path":[]},{"path":"/reference/plus-.gmod_class.html","id":null,"dir":"Reference","previous_headings":"","what":"Define a method for the + operator for gmod objects — +.gmod_class","title":"Define a method for the + operator for gmod objects — +.gmod_class","text":"Adds layers gmod object","code":""},{"path":"/reference/plus-.gmod_class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define a method for the + operator for gmod objects — +.gmod_class","text":"","code":"# S3 method for gmod_class +(gmod_obj, layer)"},{"path":"/reference/plus-.gmod_class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define a method for the + operator for gmod objects — +.gmod_class","text":"gmod_obj  layer","code":""},{"path":"/reference/plus-.gmod_class.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define a method for the + operator for gmod objects — +.gmod_class","text":"gmod_obj","code":""},{"path":"/reference/plus-.gmod_class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define a method for the + operator for gmod objects — +.gmod_class","text":"","code":"mygmod <- gmod(model_type = \"Markov\", n_cycles = 75) +  decisions(\"StandardOfCare\", \"StrategyA\", \"StrategyB\", \"StrategyAB\") #> Error in gmod(model_type = \"Markov\", n_cycles = 75): unused arguments (model_type = \"Markov\", n_cycles = 75)"},{"path":"/reference/prob2rate.html","id":null,"dir":"Reference","previous_headings":"","what":"Title — prob2rate","title":"Title — prob2rate","text":"converts prob rate using rate = -log(1-prob)","code":""},{"path":"/reference/prob2rate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title — prob2rate","text":"","code":"prob2rate(prob)"},{"path":"/reference/prob2rate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title — prob2rate","text":"prob","code":""},{"path":"/reference/prob2rate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title — prob2rate","text":"rate","code":""},{"path":"/reference/prob2rate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title — prob2rate","text":"","code":"prob2rate(prob = 0.5) #> [1] 0.6931472"},{"path":"/reference/rate2prob.html","id":null,"dir":"Reference","previous_headings":"","what":"Title — rate2prob","title":"Title — rate2prob","text":"converts rate probability using prob = 1-exp(-rate)","code":""},{"path":"/reference/rate2prob.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title — rate2prob","text":"","code":"rate2prob(rate)"},{"path":"/reference/rate2prob.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title — rate2prob","text":"rate","code":""},{"path":"/reference/rate2prob.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title — rate2prob","text":"probability","code":""},{"path":"/reference/rate2prob.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title — rate2prob","text":"","code":"rate2prob(rate = 0.3) #> [1] 0.2591818"},{"path":"/reference/states.html","id":null,"dir":"Reference","previous_headings":"","what":"Add Markov states to a gmod — states","title":"Add Markov states to a gmod — states","text":"Add Markov states gmod","code":""},{"path":"/reference/states.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Add Markov states to a gmod — states","text":"","code":"states(names, init_probs, max_cycle_in_states = NULL)"},{"path":"/reference/states.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Add Markov states to a gmod — states","text":"... Markov state names","code":""},{"path":"/reference/states.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Add Markov states to a gmod — states","text":"gmod layer Markov state names","code":""},{"path":"/reference/states.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Add Markov states to a gmod — states","text":"","code":"states(\"Healthy\", \"Sick\", \"Dead\") #> [[1]] #> [[1]]$type #> [1] \"states\" #>  #> [[1]]$states #> [1] \"Healthy\" #>  #>  #> [[2]] #> [[2]]$type #> [1] \"initial_prob\" #>  #> [[2]]$states #> [1] \"Healthy\" #>  #> [[2]]$probs #> [1] \"Sick\" #>  #>  #> [[3]] #> [[3]]$type #> [1] \"tunnels\" #>  #> [[3]]$states #> [1] \"Healthy\" #>  #> [[3]]$lengths #> [1] \"Dead\" #>  #>"},{"path":"/reference/tunnel2state.html","id":null,"dir":"Reference","previous_headings":"","what":"Title — tunnel2state","title":"Title — tunnel2state","text":"decomposes expanded state state name cycle_in_state. state tunnel, return cycle_in_state=1","code":""},{"path":"/reference/tunnel2state.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Title — tunnel2state","text":"","code":"tunnel2state(tunnel_state)"},{"path":"/reference/tunnel2state.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Title — tunnel2state","text":"tunnel_state name tunnel state","code":""},{"path":"/reference/tunnel2state.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Title — tunnel2state","text":"list consisting name state cycle_in_state value","code":""},{"path":"/reference/tunnel2state.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Title — tunnel2state","text":"","code":"tunnel2state(\"sick_tnl5\") #> $state #> [1] \"sick\" #>  #> $cycle_in_state #> [1] 5 #>"}]
